% \iffalse meta-comment
%
% Copyright (C) 2015 by Josef Friedrich <josef@friedrich.rocks>
% ----------------------------------------------------------------------
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, either version 1.3 of this license
% or (at your option) any later version.  The latest version of this
% license is in:
%
%   http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Josef Friedrich.
%
% This work consists of the files luanodelist.dtx and luanodelist.ins
% and the derived filebase luanodelist.sty and luanodelist.lua.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{luanodelist.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{luanodelist}
%<*package>
    [2015/11/13 Package to debug node lists used by LuaTeX]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage{hyperref}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}

\providecommand*{\url}{\texttt}
\GetFileInfo{luanodelist.dtx}
\title{The \textsf{luanodelist} package}
\author{%
  Josef Friedrich\\%
  \url{josef@friedrich.rocks}\\%
  \href{https://github.com/Josef-Friedrich/cloze}{github.com/Josef-Friedrich/luanodelist}%
}
\date{\fileversion~from \filedate}

\maketitle

\tableofcontents

\section{Option 'channel'}

Value "term"


\begin{verbatim}
\usepackage[channel=term]{luanodelist}
\end{verbatim}

Value "log"

\begin{verbatim}
\usepackage[channel=log]{luanodelist}
\end{verbatim}

Value "term and log"

\begin{verbatim}
\usepackage[channel={term and log}]{luanodelist}
\end{verbatim}

  \DocInput{luanodelist.dtx}
  \pagebreak
  \PrintChanges
  \pagebreak
  \PrintIndex
\end{document}
%</driver>
%<*readme>
# luanodelist

Based on the [gist of Patrick Gundlach](https://gist.github.com/pgundlach/556247).

`luanodelist` displays some debug informations of the node list in the
terminal, when you render a Latex document.

```
lualatex example.tex
```

```
This is LuaTeX, Version beta-0.79.1 (TeX Live 2014) (rev 4971)
 restricted \write18 enabled.
...
(./luanodelist.lua)) (./example.aux)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN nodelist debug
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

GLUE baselineskip: 5.05556pt;

HLIST width 345pt; height 6.94444pt; depth 1.94444pt; glue_set 205; glue_sign 1; glue_order 2;
WHATSIT name: whatsit; type: local_par;

HLIST width 15pt;
GLYPH char: "L"; lang: 0; font: 15; width: 6.25002pt;
GLYPH char: "o"; lang: 0; font: 15; width: 5.00002pt;
GLYPH char: "r"; lang: 0; font: 15; width: 3.91667pt;
GLYPH char: "e"; lang: 0; font: 15; width: 4.44444pt;
GLYPH char: "m"; lang: 0; font: 15; width: 8.33336pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "i"; lang: 0; font: 15; width: 2.77779pt;
GLYPH char: "p"; lang: 0; font: 15; width: 5.55557pt;
DISC prepostreplace;
GLYPH char: "-"; lang: 0; font: 15; width: 3.33333pt;
GLYPH char: "s"; lang: 0; font: 15; width: 3.94444pt;
GLYPH char: "u"; lang: 0; font: 15; width: 5.55557pt;
GLYPH char: "m"; lang: 0; font: 15; width: 8.33336pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "d"; lang: 0; font: 15; width: 5.55557pt;
GLYPH char: "o"; lang: 0; font: 15; width: 5.00002pt;
DISC prepostreplace;
GLYPH char: "-"; lang: 0; font: 15; width: 3.33333pt;
GLYPH char: "l"; lang: 0; font: 15; width: 2.77779pt;
GLYPH char: "o"; lang: 0; font: 15; width: 5.00002pt;
GLYPH char: "r"; lang: 0; font: 15; width: 3.91667pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "s"; lang: 0; font: 15; width: 3.94444pt;
GLYPH char: "i"; lang: 0; font: 15; width: 2.77779pt;
GLYPH char: "t"; lang: 0; font: 15; width: 3.8889pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "a"; lang: 0; font: 15; width: 5.00002pt;
GLYPH char: "m"; lang: 0; font: 15; width: 8.33336pt;
GLYPH char: "e"; lang: 0; font: 15; width: 4.44444pt;
GLYPH char: "t"; lang: 0; font: 15; width: 3.8889pt;
GLYPH char: "."; lang: 0; font: 15; width: 2.77779pt;
PENALTY 10000
GLUE parfillskip: 0pt + 1 fil;
GLUE rightskip: 0pt;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END nodelist debug
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

...
Output written on example.pdf (1 page, 12841 bytes).
Transcript written on example.log.
```

# UTF8 Box drawing symbols

## Light

```
│ │
│ ├─┤field1: 1pt├┤field2: 1pt│
│ └─
└─
```

## Heavy

```
┃ ┃
┃ ┣━┫field1: 1pt┣┫field2: 1pt┃
┃ ┗━
┗━
```

## Double

```
║ ║
║ ╠═╣field1: 1pt╠╣field2: 1pt║
║ ╚═
╚═
```

%</readme>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.1}{2015/06/16}{Converted to DTX file}
% \changes{v1.0}{2015/07/08}{Inital release}
%
% \DoNotIndex{\newcommand,\newenvironment,\def,\directlua}
%
% \StopEventually{}
% \pagebreak
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
% \MacroTopsep = 10pt plus 2pt minus 2pt
% \MacrocodeTopsep = 10pt plus 1.2pt minus 1pt
%
% \makeatletter
% \c@CodelineNo 25 \relax
% \makeatother
%
% \subsection{The file \tt{luanodelist.sty}}
%
%
%    \begin{macrocode}
\RequirePackage{luatexbase-mcb}
\RequirePackage{kvoptions}

\SetupKeyvalOptions{
  family=LN,
  prefix=LN@
}
\DeclareStringOption[term and log]{channel}
\DeclareStringOption[postlinebreak]{callback}
\DeclareStringOption[1]{verbosity}

\ProcessKeyvalOptions*

\newcommand{\setluanodelist}[1]{\setkeys{LN}{#1}}

\directlua{
  local options = {}
  options.verbosity = tonumber(\LN@verbosity)
  options.channel = '\LN@channel'
  options.callback = '\LN@callback'

  package.path = './lua/?.lua;' .. package.path

  luanodelist = require("luanodelist")
  luanodelist.get_options(options)
  luanodelist.execute()
}
%    \end{macrocode}
%
% \iffalse
%</package>
%<*luamain>
% \fi
%
% \makeatletter
% \c@CodelineNo 0 \relax
% \makeatother
%
% \subsection{The file \tt{luanodelist.lua}}
%
%    \begin{macrocode}
local colors = require('ansicolors')
local c = colors
%    \end{macrocode}
%
%    \begin{macrocode}
local nodex = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local template = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local tree = {}
%    \end{macrocode}
%
% Nodes in Lua\TeX are connected. The tree view distinguishs betweens
% the |list| and |field| connections.

% \begin{itemize}
%  \item |list|: Nodes, which are double connected by |next| and
%        |previous| fields.
%  \item |field|: Connections to nodes by other fields than |next| and
%        |previous| fields, e. g. |head|, |pre|.
% \end{itemize}
%
% The lua table named |tree| holds states values for the present tree
% item.
% \begin{verbatim}
%  tree:
%    - 1:
%      - list: continue
%      - field: stop
%    - 2:
%      - list: continue
%      - field: stop
% \end{verbatim}
%    \begin{macrocode}
tree.state = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local base = {}
%    \end{macrocode}
%
% Nodes in Lua\TeX are connected. The tree view distinguishs betweens
% the |list| and |field| connections.

% \begin{itemize}
%  \item |list|: Nodes, which are double connected by |next| and
%        |previous| fields.
%  \item |field|: Connections to nodes by other fields than |next| and
%        |previous| fields, e. g. |head|, |pre|.
% \end{itemize}
%
% The lua table named |tree| holds states values for the present tree
% item.
% \begin{verbatim}
%  tree:
%    - 1:
%      - list: continue
%      - field: stop
%    - 2:
%      - list: continue
%      - field: stop
% \end{verbatim}
%    \begin{macrocode}
tree.state = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local options
%    \end{macrocode}
%
% \subsubsection{nodex --- node extended}
%
% Get the node id form, e. g.:
% \begin{verbatim}
% <node    nil <    172 >    nil : hlist 2>
% \end{verbatim}
%    \begin{macrocode}
function nodex.node_id(n)
  return string.gsub(tostring(n), '^<node%s+%S+%s+<%s+(%d+).*', '%1')
end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodex.subtype(n)
  local typ = node.type(n.id)

  local subtypes = {
    -- 0
    hlist = {
      [0] = 'unknown',
      [1] = 'line',
      [2] = 'box',
      [3] = 'indent',
      [4] = 'alignment',
      [5] = 'cell',
      [6] = 'equation',
      [7] = 'equationnumber',
    },
    -- 1
    vlist = {
      [0] = 'unknown',
      [4] = 'alignment',
      [5] = 'cell',
    },
    -- 2
    rule = {
      [0] = 'unknown',
      [1] = 'box',
      [2] = 'image',
      [3] = 'empty',
      [4] = 'user',
    },
-- ins (3)
-- mark (4)
    -- 5
    adjust = {
      [0] = 'normal',
      [1] = 'pre',
    },
    -- 6
    boundary = {
      [0] = 'cancel',
      [1] = 'user',
      [2] = 'protrusion',
      [3] = 'word',
    },
    -- 7
    disc  = {
      [0] = 'discretionary',
      [1] = 'explicit',
      [2] = 'automatic',
      [3] = 'regular',
      [4] = 'first',
      [5] = 'second',
    },
-- whatsit (8)
-- local_par (9)
-- dir (10)
    -- 11
    math = {
      [0] = 'beginmath',
      [1] = 'endmath',
    },
    -- 12
    glue = {
      [0]   = 'userskip',
      [1]   = 'lineskip',
      [2]   = 'baselineskip',
      [3]   = 'parskip',
      [4]   = 'abovedisplayskip',
      [5]   = 'belowdisplayskip',
      [6]   = 'abovedisplayshortskip',
      [7]   = 'belowdisplayshortskip',
      [8]   = 'leftskip',
      [9]   = 'rightskip',
      [10]  = 'topskip',
      [11]  = 'splittopskip',
      [12]  = 'tabskip',
      [13]  = 'spaceskip',
      [14]  = 'xspaceskip',
      [15]  = 'parfillskip',
      [16]  = 'mathskip',
      [17]  = 'thinmuskip',
      [18]  = 'medmuskip',
      [19]  = 'thickmuskip',
      [98]  = 'conditionalmathskip',
      [99]  = 'muglue',
      [100] = 'leaders',
      [101] = 'cleaders',
      [102] = 'xleaders',
      [103] = 'gleaders',
    },
    -- 13
    kern = {
      [0] = 'fontkern',
      [1] = 'userkern',
      [2] = 'accentkern',
      [3] = 'italiccorrection',
    },
-- penalty (14)
-- unset (15)
-- style (16)
-- choice (17)
    -- 18
    noad = {
      [0] = 'ord',
      [1] = 'opdisplaylimits',
      [2] = 'oplimits',
      [3] = 'opnolimits',
      [4] = 'bin',
      [5] = 'rel',
      [6] = 'open',
      [7] = 'close',
      [8] = 'punct',
      [9] = 'inner',
      [10] = 'under',
      [11] = 'over',
      [12] = 'vcenter',
    },
    -- 19
    radical = {
      [0] = 'radical',
      [1] = 'uradical',
      [2] = 'uroot',
      [3] = 'uunderdelimiter',
      [4] = 'uoverdelimiter',
      [5] = 'udelimiterunder',
      [6] = 'udelimiterover',
    },
-- fraction (20)
     -- 21
    accent = {
      [0] = 'bothflexible',
      [1] = 'fixedtop',
      [2] = 'fixedbottom',
      [3] = 'fixedboth',
    },
    -- 22
    fence = {
      [0] = 'unset',
      [1] = 'left',
      [2] = 'middle',
      [3] = 'right',
    },
-- math_char (23)
-- sub_box (24)
-- sub_mlist (25)
-- math_text_char (26)
-- delim (27)
-- margin_kern (28)
    --  29
    glyph = {
      [0] = 'character',
      [1] = 'ligature',
      [2] = 'ghost',
      [3] = 'left',
      [4] = 'right',
    },
-- align_record (30)
-- pseudo_file (31)
-- pseudo_line (32)
-- page_insert (33)
-- split_insert (34)
-- expr_stack (35)
-- nested_list (36)
-- span (37)
-- attribute (38)
-- glue_spec (39)
-- attribute_list (40)
-- temp (41)
-- align_stack (42)
-- movement_stack (43)
-- if_stack (44)
-- unhyphenated (45)
-- hyphenated (46)
-- delta (47)
-- passive (48)
-- shape (49)
  }

  subtypes.whatsit = node.whatsits()

  local out = ''
  if subtypes[typ] and subtypes[typ][n.subtype] then
    out = subtypes[typ][n.subtype]

    if options.verbosity > 1 then
      out = out .. template.type_id(n.subtype)
    end

    return out
  else
    return tostring(n.subtype)
  end

  assert(false)
end
%    \end{macrocode}
%
% \subsubsection{template}
%
%    \begin{macrocode}
function template.key_value(key, value)
  return colors.yellow .. key .. ': ' .. colors.white .. value .. '; ' .. colors.reset
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.heading(text)
  return '\n' .. template.line() .. '% ' .. text .. template.line() .. '\n'
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.length(input)
  input = tonumber(input)
  input = input / 2^16
  input = math.floor((input * 10^2) + 0.5) / (10^2)
  return string.format('%gpt', input)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.char(input)
  return string.format('%q', unicode.utf8.char(input))
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.line()
  return '\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n'
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.frame(text, callback)
  local begin_text = 'BEGIN nodelist debug (Callback: ' .. tostring(callback) .. ')'
  local end_text = 'END nodelist debug'
  return template.heading(begin_text) .. text .. template.heading(end_text)
end
%    \end{macrocode}
% t = type
%    \begin{macrocode}
function template.type(t, id)
  local out = ''
  out = template.type_color(t) .. string.upper(t)

  if options.verbosity > 1 then
    out = out .. template.type_id(id)
  end

  return out .. colors.reset  .. ' '
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.type_id(id)
  return '[' .. tostring(id) .. ']'
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.branch(connection_type, connection_state, last)
  local c = connection_type
  local s = connection_state
  local l = last
  if c == 'list' and s == 'stop' and l == false then
    return ' '
  elseif c == 'field' and s == 'stop' and l == false then
    return ' '
  elseif c == 'list' and s == 'continue' and l == false then
    return '│ '
  elseif c == 'field' and s == 'continue' and l == false then
    return '║ '
  elseif c == 'list' and s == 'continue' and l == true then
    return '├─'
  elseif c == 'field' and s == 'continue' and l == true then
    return '╠═'
  elseif c == 'list' and s == 'stop' and l == true then
    return '└─'
  elseif c == 'field' and s == 'stop' and l == true then
    return '╚═'
  end
end
%    \end{macrocode}

%    \begin{macrocode}
function template.branches(level, connection_type)
  local out = ''

  for i = 1, level - 1  do
    out = out .. template.branch('list', tree.state[i]['list'], false)
    out = out .. template.branch('field', tree.state[i]['field'], false)
  end
%    \end{macrocode}
% Format the last branches
%    \begin{macrocode}
  if connection_type == 'list' then
    out = out .. template.branch('list', tree.state[level]['list'], true)
  else
    out = out .. template.branch('list', tree.state[level]['list'], false)
    out = out .. template.branch('field', tree.state[level]['field'], true)
  end

  return out
end
%    \end{macrocode}
%
%    \begin{macrocode}
template.node_colors = {
  hlist          = c.red,
  vlist          = c.green,
  rule           = c.yellow,
  ins            = c.blue,
  mark           = c.magenta,
  adjust         = c.cyan,
  boundary       = c.bright .. c.red,
  disc           = c.bright .. c.green,
  whatsit        = c.bright .. c.yellow,
  local_par      = c.bright .. c.blue,
  dir            = c.bright .. c.magenta,
  math           = c.bright .. c.cyan,
  glue           = c.dim .. c.red,
  kern           = c.dim .. c.green,
  penalty        = c.dim .. c.yellow,
  unset          = c.dim .. c.blue,
  style          = c.dim .. c.magenta,
  choice         = c.dim .. c.cyan,
  noad           = c.red,
  radical        = c.green,
  fraction       = c.yellow,
  accent         = c.blue,
  fence          = c.magenta,
  math_char      = c.cyan,
  sub_box        = c.bright .. c.red,
  sub_mlist      = c.bright .. c.green,
  math_text_char = c.bright .. c.yellow,
  delim          = c.bright .. c.blue,
  margin_kern    = c.bright .. c.magenta,
  glyph          = c.bright .. c.cyan,
  align_record   = c.dim .. c.red,
  pseudo_file    = c.dim .. c.green,
  pseudo_line    = c.dim .. c.yellow,
  page_insert    = c.dim .. c.blue,
  split_insert   = c.dim .. c.magenta,
  expr_stack     = c.dim .. c.cyan,
  nested_list    = c.red,
  span           = c.green,
  attribute      = c.yellow,
  glue_spec      = c.magenta,
  attribute_list = c.cyan,
  temp           = c.magenta,
  align_stack    = c.bright .. c.red,
  movement_stack = c.bright .. c.green,
  if_stack       = c.bright .. c.yellow,
  unhyphenated   = c.bright .. c.magenta,
  hyphenated     = c.bright .. c.cyan,
  delta          = c.red,
  passive        = c.green,
  shape          = c.yellow,
}
%    \end{macrocode}
%
%    \begin{macrocode}
function template.type_color(id)
  return  template.node_colors[id]
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.print(text)
  print(text)
end
%    \end{macrocode}
%
% \subsubsection{tree}
%
%    \begin{macrocode}
function tree.format_field(head, field)
  local out = ''

  if not head[field] or head[field] == 0 then
    return ''
  end

  if options.verbosity < 2 and field == 'prev' or field == 'next' or field == 'id' or field == 'attr' then
    return ''
  end

  if field == 'prev' or field == 'next' then
    out = nodex.node_id(head[field])
  elseif field == 'subtype' then
    out = nodex.subtype(head)
  elseif field == 'width' or field == 'height' or field == 'depth' then
    out = template.length(head[field])
  elseif field == 'char' then
    out = template.char(head[field])
  else
    out = tostring(head[field])
  end

  return template.key_value(field, out)
end
%    \end{macrocode}
%
% |level| is a integer beginning with 1. The variable |connection_type|
% is a string, which can be either |list| or |field|. The variable
% |connection_state| is a string, which can be either |continue| or
% |stop|.
%    \begin{macrocode}
function tree.set_state(level, connection_type, connection_state)
  if not tree.state[level] then
    tree.state[level] = {}
  end
  tree.state[level][connection_type] = connection_state
end
%    \end{macrocode}
%
%    \begin{macrocode}
function tree.analyze_node(head, level)
  local out = {}
  local connection_state

  out = template.type(node.type(head.id), head.id)

  if options.verbosity > 1 then
    out = out .. template.key_value('no', nodex.node_id(head))
  end

  local tmp = {}
  local r = {} -- recurison

  fields = node.fields(head.id, head.subtype)

  for field_id, field_name in pairs(fields) do
    if field_name ~= 'next' and
      field_name ~= 'prev' and
      field_name ~= 'attr' and
      node.is_node(head[field_name]) then
      r[field_name] = head[field_name]
    else
      tmp[#tmp + 1] = tree.format_field(head, field_name)
    end
  end

  if head.next then
    connection_state = 'continue'
  else
    connection_state = 'stop'
  end

  tree.set_state(level, 'list', connection_state)
  template.print(template.branches(level, 'list') .. out .. table.concat(tmp, ''))

  local max = 0
  for _ in pairs(r) do
    max = max + 1
  end

  local count = 0
  for field_name, recursion_node in pairs(r) do
    count = count + 1
    if count == max then
      connection_state = 'stop'
    else
      connection_state = 'continue'
    end

    tree.set_state(level, 'field', connection_state)
    template.print(template.branches(level, 'field') .. field_name .. ':')
    tree.analyze_list(recursion_node, level + 1)
  end

end
%    \end{macrocode}
%
%    \begin{macrocode}
function tree.analyze_list(head, level)
  while head do
    tree.analyze_node(head, level)
    head = head.next
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function tree.analyze(head)
  print('\n')
  tree.analyze_list(head, 1)
  return head
end
%    \end{macrocode}
%
% \subsubsection{base}
%
%    \begin{macrocode}
function base.get_callback(key)
  if key == 'prelinebreak' then callback = 'pre_linebreak_filter'
  elseif key == 'linebreak' then callback = 'linebreak_filter'
  elseif key == 'postlinebreak' then callback = 'post_linebreak_filter'
  elseif key == 'hpack' then callback = 'hpack_filter'
  elseif key == 'vpack' then callback = 'vpack_filter'
  elseif key == 'hyphenate' then callback = 'hyphenate'
  elseif key == 'ligaturing' then callback = 'ligaturing'
  elseif key == 'kerning' then callback = 'kerning'
  elseif key == 'mhlist' then callback = 'mlist_to_hlist'
  else callback = 'post_linebreak_filter'
  end

  return callback
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.get_options(localoptions)
  options = localoptions
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.execute()
  luatexbase.add_to_callback(base.get_callback(options.callback), tree.analyze, 'tree')
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.analyze(head)
  local out = template.line() ..
    tree.analyze_list(head, 1) ..
    template.line()

  template.print(out)
end
%    \end{macrocode}
%
%    \begin{macrocode}
return base
%    \end{macrocode}
% \iffalse
%</luamain>
%<*luaansicolors>
% \fi
%
% \makeatletter
% \c@CodelineNo 0 \relax
% \makeatother
%
% \subsection{The file \tt{ansicolors.lua}}
%
%    \begin{macrocode}
-- Copyright (c) 2009 Rob Hoelz <rob@hoelzro.net>
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-- THE SOFTWARE.

local pairs = pairs
local tostring = tostring
local setmetatable = setmetatable
local schar = string.char

module 'ansicolors'

local colormt = {}

function colormt:__tostring()
    return self.value
end

function colormt:__concat(other)
    return tostring(self) .. tostring(other)
end

function colormt:__call(s)
    return self .. s .. _M.reset
end

colormt.__metatable = {}

local function makecolor(value)
    return setmetatable({ value = schar(27) .. '[' .. tostring(value) .. 'm' }, colormt)
end

local colors = {
    -- attributes
    reset = 0,
    clear = 0,
    bright = 1,
    dim = 2,
    underscore = 4,
    blink = 5,
    reverse = 7,
    hidden = 8,

    -- foreground
    black = 30,
    red = 31,
    green = 32,
    yellow = 33,
    blue = 34,
    magenta = 35,
    cyan = 36,
    white = 37,

    -- background
    onblack = 40,
    onred = 41,
    ongreen = 42,
    onyellow = 43,
    onblue = 44,
    onmagenta = 45,
    oncyan = 46,
    onwhite = 47,
}

for c, v in pairs(colors) do
    _M[c] = makecolor(v)
end
%    \end{macrocode}
% \iffalse
%</luaansicolors>
% \fi
%
% \Finale
\endinput
