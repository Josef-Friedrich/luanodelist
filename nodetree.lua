
-- Add some informations and references
-- This is a autogenerated file.
-- For more informations please read the manual.
-- http://mirrors.ctan.org/macros/luatex/generic/nodetree/nodetree.pdf

if not modules then modules = { } end modules ['nodetree'] = {
  version   = '1.2',
  comment   = 'nodetree',
  author    = 'Josef Friedrich',
  copyright = 'Josef Friedrich',
  license   = 'The LaTeX Project Public License Version 1.3c 2008-05-04'
}

local node_extended = {}

local template = {}

local tree = {}

-- Nodes in Lua\TeX{} are connected. The nodetree view distinguishs
-- between the |list| and |field| connections.

-- \begin{itemize}
--  \item |list|: Nodes, which are double connected by |next| and
--        |previous| fields.
--  \item |field|: Connections to nodes by other fields than |next| and
--        |previous| fields, e. g. |head|, |pre|.
-- \end{itemize}

-- The lua table named |tree.state| holds state values of the current
-- tree item.

-- |tree.state|:
-- \begin{itemize}
-- \item |1| (level):
-- \begin{itemize}
-- \item |list|: |continue|
-- \item |field|: |stop|
-- \end{itemize}
-- \item |2|:
-- \begin{itemize}
-- \item |list|: |continue|
-- \item |field|: |stop|
-- \end{itemize}
-- \end{itemize}
tree.state = {}
-- A counter for the compiled TeX examples. Some TeX code snippets
-- a written into file, wrapped with some TeX boilerplate code.
-- This written files are compiled.
local example_counter = 0
-- Table to bundle all callback wrapper functions.
local callbacks = {}

local export = {}
-- The default options
local options = {
  verbosity = 1,
  callback = 'postlinebreak',
  engine = 'luatex',
  color = 'colored',
  decimalplaces = 2,
  unit = 'pt',
  channel = 'term',
}
-- File descriptor
local output_file

-- \subsubsection{node\_extended --- Extend the node library}

---
-- Get the ID of a node. We have to convert the node into a string and
-- than have to extract the ID from this string using a regular
-- expression. If you convert a node into a string it looks like:
-- |<node    nil <    172 >    nil : hlist 2>|.
function node_extended.node_id(n)
  return string.gsub(tostring(n), '^<node%s+%S+%s+<%s+(%d+).*', '%1')
end

---
function node_extended.subtype(n)
  local typ = node.type(n.id)
  local subtypes = {
-- \paragraph{hlist (0)}
    hlist = {
      [0] = 'unknown',
      [1] = 'line',
      [2] = 'box',
      [3] = 'indent',
      [4] = 'alignment',
      [5] = 'cell',
      [6] = 'equation',
      [7] = 'equationnumber',
      [8] = 'math',
      [9] = 'mathchar',
      [10] = 'hextensible',
      [11] = 'vextensible',
      [12] = 'hdelimiter',
      [13] = 'vdelimiter',
      [14] = 'overdelimiter',
      [15] = 'underdelimiter',
      [16] = 'numerator',
      [17] = 'denominator',
      [18] = 'limits',
      [19] = 'fraction',
      [20] = 'nucleus',
      [21] = 'sup',
      [22] = 'sub',
      [23] = 'degree',
      [24] = 'scripts',
      [25] = 'over',
      [26] = 'under',
      [27] = 'accent',
      [28] = 'radical',
    },
-- \paragraph{vlist (1)}
    vlist = {
      [0] = 'unknown',
      [4] = 'alignment',
      [5] = 'cell',
    },
-- \paragraph{rule (2)}
    rule = {
      [0] = 'normal',
      [1] = 'box',
      [2] = 'image',
      [3] = 'empty',
      [4] = 'user',
      [5] = 'over',
      [6] = 'under',
      [7] = 'fraction',
      [8] = 'radical',
      [9] = 'outline',
    },

-- \noindent
-- Nodes without subtypes:
-- \begin{compactitem}
-- \item ins (3)
-- \item mark (4)
-- \end{compactitem}
-- \paragraph{adjust (5)}
    adjust = {
      [0] = 'normal',
      [1] = 'pre',
    },
-- \paragraph{boundary (6)}
    boundary = {
      [0] = 'cancel',
      [1] = 'user',
      [2] = 'protrusion',
      [3] = 'word',
    },
-- \paragraph{disc (7)}
    disc  = {
      [0] = 'discretionary',
      [1] = 'explicit',
      [2] = 'automatic',
      [3] = 'regular',
      [4] = 'first',
      [5] = 'second',
    },

-- \noindent
-- Nodes without subtypes:
-- \begin{compactitem}
-- \item whatsit (8)
-- \item local\_par (9)
-- \item dir (10)
-- \end{compactitem}

-- \paragraph{math (11)}
    math = {
      [0] = 'beginmath',
      [1] = 'endmath',
    },

-- \paragraph{glue (12)}
    glue = {
      [0]   = 'userskip',
      [1]   = 'lineskip',
      [2]   = 'baselineskip',
      [3]   = 'parskip',
      [4]   = 'abovedisplayskip',
      [5]   = 'belowdisplayskip',
      [6]   = 'abovedisplayshortskip',
      [7]   = 'belowdisplayshortskip',
      [8]   = 'leftskip',
      [9]   = 'rightskip',
      [10]  = 'topskip',
      [11]  = 'splittopskip',
      [12]  = 'tabskip',
      [13]  = 'spaceskip',
      [14]  = 'xspaceskip',
      [15]  = 'parfillskip',
      [16]  = 'mathskip',
      [17]  = 'thinmuskip',
      [18]  = 'medmuskip',
      [19]  = 'thickmuskip',
      [98]  = 'conditionalmathskip',
      [99]  = 'muglue',
      [100] = 'leaders',
      [101] = 'cleaders',
      [102] = 'xleaders',
      [103] = 'gleaders',
    },
-- \paragraph{kern (13)}
    kern = {
      [0] = 'fontkern',
      [1] = 'userkern',
      [2] = 'accentkern',
      [3] = 'italiccorrection',
    },

-- \paragraph{penalty (14)}
    penalty = {
      [0] = 'userpenalty',
      [1] = 'linebreakpenalty',
      [2] = 'linepenalty',
      [3] = 'wordpenalty',
      [4] = 'finalpenalty',
      [5] = 'noadpenalty',
      [6] = 'beforedisplaypenalty',
      [7] = 'afterdisplaypenalty',
      [8] = 'equationnumberpenalty',
    },

-- \noindent
-- Nodes without subtypes:
-- \begin{compactitem}
-- \item penalty (14)
-- \item unset (15)
-- \item style (16)
-- \item choice (17)
-- \end{compactitem}

-- \paragraph{noad (18)}
    noad = {
      [0] = 'ord',
      [1] = 'opdisplaylimits',
      [2] = 'oplimits',
      [3] = 'opnolimits',
      [4] = 'bin',
      [5] = 'rel',
      [6] = 'open',
      [7] = 'close',
      [8] = 'punct',
      [9] = 'inner',
      [10] = 'under',
      [11] = 'over',
      [12] = 'vcenter',
    },
-- \paragraph{radical (19)}
    radical = {
      [0] = 'radical',
      [1] = 'uradical',
      [2] = 'uroot',
      [3] = 'uunderdelimiter',
      [4] = 'uoverdelimiter',
      [5] = 'udelimiterunder',
      [6] = 'udelimiterover',
    },

-- \noindent
-- Nodes without subtypes:
-- \begin{compactitem}
-- \item fraction (20)
-- \end{compactitem}

-- \paragraph{accent (21)}
    accent = {
      [0] = 'bothflexible',
      [1] = 'fixedtop',
      [2] = 'fixedbottom',
      [3] = 'fixedboth',
    },
-- \paragraph{fence (22)}
    fence = {
      [0] = 'unset',
      [1] = 'left',
      [2] = 'middle',
      [3] = 'right',
      [4] = 'no',
    },

-- \noindent
-- Nodes without subtypes:
-- \begin{compactitem}
-- \item math\_char (23)
-- \item sub\_box (24)
-- \item sub\_mlist (25)
-- \item math\_text\_char (26)
-- \item delim (27)
-- \item margin\_kern (28)
-- \end{compactitem}

-- \paragraph{margin\_kern (28)}
    margin_kern = {
      [0] = 'left',
      [1] = 'right',
    },

-- \paragraph{glyph (29)}
    glyph = {
      [0] = 'character',
      [1] = 'ligature',
      [2] = 'ghost',
      [3] = 'left',
      [4] = 'right',
    },

-- \noindent
-- Nodes without subtypes:
-- \begin{compactitem}
-- \item align\_record (30)
-- \item pseudo\_file (31)
-- \item pseudo\_line (32)
-- \item page\_insert (33)
-- \item split\_insert (34)
-- \item expr\_stack (35)
-- \item nested\_list (36)
-- \item span (37)
-- \item attribute (38)
-- \item glue\_spec (39)
-- \item attribute\_list (40)
-- \item temp (41)
-- \item align\_stack (42)
-- \item movement\_stack (43)
-- \item if\_stack (44)
-- \item unhyphenated (45)
-- \item hyphenated (46)
-- \item delta (47)
-- \item passive (48)
-- \item shape (49)
-- \end{compactitem}
  }
  subtypes.whatsit = node.whatsits()
  local out = ''
  if subtypes[typ] and subtypes[typ][n.subtype] then
    out = subtypes[typ][n.subtype]
    if options.verbosity > 1 then
      out = out .. template.type_id(n.subtype)
    end
    return out
  else
    return tostring(n.subtype)
  end
  assert(false)
end

-- \subsubsection{template --- Template function}

---
function template.underscore(string)
  if options.channel == 'tex' then
    return string.gsub(string, '_', '\\_')
  else
    return string
  end
end

---
function template.escape(string)
  if options.channel == 'tex' then
    return string.gsub(string, [[\]], [[\string\]])
  else
    return string
  end
end

function template.round(number)
  local mult = 10^(options.decimalplaces or 0)
  return math.floor(number * mult + 0.5) / mult
end

---
function template.whitespace(count)
  local whitespace, out = '', ''
  if options.channel == 'tex' then
    whitespace = '\\hspace{0.5em}'
  else
    whitespace = ' '
  end
  if not count then
    count = 1
  end
  for i = 1, count do
    out = out .. whitespace
  end
  return out
end

function template.length(input)
  input = tonumber(input)
  input = input / tex.sp('1' .. options.unit)
  return string.format('%g%s', template.round(input), options.unit)
end

---
function template.fill(number, order, field)
  if order ~= nil and order ~= 0 then
    if field == 'stretch' then
      out = '+'
    else
      out = '-'
    end
    return out .. string.format(
      '%gfi%s', number / 2^16,
      string.rep('l', order - 1)
    )
  else
    return template.length(number)
  end
end

---
template.node_colors = {
  hlist = {'red', 'bright'},
  vlist = {'green', 'bright'},
  rule = {'blue', 'bright'},
  ins = {'blue'},
  mark = {'magenta'},
  adjust = {'cyan'},
  boundary = {'red', 'bright'},
  disc = {'green', 'bright'},
  whatsit = {'yellow', 'bright'},
  local_par = {'blue', 'bright'},
  dir = {'magenta', 'bright'},
  math = {'cyan', 'bright'},
  glue = {'magenta', 'bright'},
  kern = {'green', 'bright'},
  penalty = {'yellow', 'bright'},
  unset = {'blue'},
  style = {'magenta'},
  choice = {'cyan'},
  noad = {'red'},
  radical = {'green'},
  fraction = {'yellow'},
  accent = {'blue'},
  fence = {'magenta'},
  math_char = {'cyan'},
  sub_box = {'red', 'bright'},
  sub_mlist = {'green', 'bright'},
  math_text_char = {'yellow', 'bright'},
  delim = {'blue', 'bright'},
  margin_kern = {'magenta', 'bright'},
  glyph = {'cyan', 'bright'},
  align_record = {'red'},
  pseudo_file = {'green'},
  pseudo_line = {'yellow'},
  page_insert = {'blue'},
  split_insert = {'magenta'},
  expr_stack = {'cyan'},
  nested_list = {'red'},
  span = {'green'},
  attribute = {'yellow'},
  glue_spec = {'magenta'},
  attribute_list = {'cyan'},
  temp = {'magenta'},
  align_stack = {'red', 'bright'},
  movement_stack = {'green', 'bright'},
  if_stack = {'yellow', 'bright'},
  unhyphenated = {'magenta', 'bright'},
  hyphenated = {'cyan', 'bright'},
  delta = {'red'},
  passive = {'green'},
  shape = {'yellow'},
}

---
function template.color_code(code)
  return string.char(27) .. '[' .. tostring(code) .. 'm'
end

--
-- \href{https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters}
-- {SGR (Select Graphic Rendition) Parameters}

-- \paragraph{attributes}

-- \begin{tabular}{ll}
-- reset & 0 \\
-- clear & 0 \\
-- bright & 1 \\
-- dim & 2 \\
-- underscore & 4 \\
-- blink & 5 \\
-- reverse & 7 \\
-- hidden & 8 \\
-- \end{tabular}

-- \paragraph{foreground}

-- \begin{tabular}{ll}
-- black & 30 \\
-- red & 31 \\
-- green & 32 \\
-- yellow & 33 \\
-- blue & 34 \\
-- magenta & 35 \\
-- cyan & 36 \\
-- white & 37 \\
-- \end{tabular}

-- \paragraph{background}

-- \begin{tabular}{ll}
-- onblack & 40 \\
-- onred & 41 \\
-- ongreen & 42 \\
-- onyellow & 43 \\
-- onblue & 44 \\
-- onmagenta & 45 \\
-- oncyan & 46 \\
-- onwhite & 47 \\
-- \end{tabular}

function template.color(color, mode, background)
  if options.color ~= 'colored' then
    return ''
  end

  local out = ''
  local code = ''

  if mode == 'bright' then
    out = template.color_code(1)
  elseif mode == 'dim' then
    out = template.color_code(2)
  end

  if not background then
    if color == 'reset' then code = 0
    elseif color == 'red' then code = 31
    elseif color == 'green' then code = 32
    elseif color == 'yellow' then code = 33
    elseif color == 'blue' then code = 34
    elseif color == 'magenta' then code = 35
    elseif color == 'cyan' then code = 36
    else code = 37 end
  else
    if color == 'black' then code = 40
    elseif color == 'red' then code = 41
    elseif color == 'green' then code = 42
    elseif color == 'yellow' then code = 43
    elseif color == 'blue' then code = 44
    elseif color == 'magenta' then code = 45
    elseif color == 'cyan' then code = 46
    elseif color == 'white' then code = 47
    else code = 40 end
  end
  return out .. template.color_code(code)
end

---
function template.color_tex(color, mode, background)
  if not mode then mode = '' end
  return 'NT' .. color .. mode
end

---
function template.colored_string(string, color, mode, background)
  if options.channel == 'tex' then
    return '\\textcolor{' ..
      template.color_tex(color, mode, background) ..
      '}{' ..
      string ..
      '}'
  else
   return template.color(color, mode, background) .. string .. template.color('reset')
  end
end

---
function template.table_inline(o)
  local tex_escape = ''
  if options.channel == 'tex' then
    tex_escape = '\\'
  end
  if type(o) == 'table' then
     local s = tex_escape .. '{ '
     for k,v in pairs(o) do
        if type(k) ~= 'number' then k = '"'..k..'"' end
        s = s .. '['..k..'] = ' .. template.table_inline(v) .. ', '
     end
     return s .. tex_escape .. '} '
  else
     return tostring(o)
  end
end

---
function template.key_value(key, value, color)
  if type(color) ~= 'string' then
    color = 'yellow'
  end
  if options.channel == 'tex' then
    key = template.underscore(key)
  end
  local out = template.colored_string(key .. ':', color)
  if value then
    out = out .. ' ' .. value .. '; '
  end
  return out
end

---
function template.char(input)
  input = string.format('%q', unicode.utf8.char(input))
  if options.channel == 'tex' then
    input = template.escape(input)
  end
  return input
end

---
function template.type(type, id)
  local out = ''
  if options.channel == 'tex' then
    out = template.underscore(type)
  else
    out = type
  end
  out = string.upper(out)
  if options.verbosity > 1 then
    out = out .. template.type_id(id)
  end
  return template.colored_string(
    out .. template.whitespace(),
    template.node_colors[type][1],
    template.node_colors[type][2]
  )
end

---
function template.callback_variable(variable_name, variable)
  if variable ~= nil and variable ~= '' then
    template.print(
      template.underscore(variable_name) .. ': ' ..
      tostring(variable) ..
      template.new_line()
    )
  end
end

---
function template.line(length)
  local out = ''
  if length == 'long' then
    out = '------------------------------------------'
  else
    out = '-----------------------'
  end
    return out .. template.new_line()
end

---
function template.node_begin()
  if options.channel == 'tex' then
    return '\\mbox{'
  else
    return ''
  end
end

---
function template.node_end()
  if options.channel == 'tex' then
    return '}'
  else
    return ''
  end
end

---
function template.new_line_character()
  if options.channel == 'tex' then
    return '\\par\n'
  else
    return '\n'
  end
end

---
function template.new_line(count)
  local out = ''
  if not count then
    count = 1
  end
  for i = 1, count do
    out = out .. template.new_line_character()
  end
  return out
end

---
function template.callback(callback_name, variables)
  template.print(
    template.new_line(2) ..
    'Callback: ' ..
    template.colored_string(template.underscore(callback_name), 'red', '', true) ..
    template.new_line()
  )
  if variables then
    for name, value in pairs(variables) do
      if value ~= nil and value ~= '' then
        template.print(
          '- ' ..
          template.underscore(name) ..
          ': ' ..
          tostring(value) ..
          template.new_line()
        )
      end
    end
  end
  template.print(template.line('long'))
end

---
function template.type_id(id)
  return '[' .. tostring(id) .. ']'
end

---
function template.branch(connection_type, connection_state, last)
  local c = connection_type
  local s = connection_state
  local l = last
  if c == 'list' and s == 'stop' and l == false then
    return template.whitespace(2)
  elseif c == 'field' and s == 'stop' and l == false then
    return template.whitespace(2)
  elseif c == 'list' and s == 'continue' and l == false then
    return '│' .. template.whitespace()
  elseif c == 'field' and s == 'continue' and l == false then
    return '║' .. template.whitespace()
  elseif c == 'list' and s == 'continue' and l == true then
    return '├─'
  elseif c == 'field' and s == 'continue' and l == true then
    return '╠═'
  elseif c == 'list' and s == 'stop' and l == true then
    return '└─'
  elseif c == 'field' and s == 'stop' and l == true then
    return '╚═'
  end
  return ''
end

---
function template.branches(level, connection_type)
  local out = ''
  for i = 1, level - 1  do
    out = out .. template.branch('list', tree.state[i]['list'], false)
    out = out .. template.branch('field', tree.state[i]['field'], false)
  end
-- Format the last branches
  if connection_type == 'list' then
    out = out .. template.branch('list', tree.state[level]['list'], true)
  else
    out = out .. template.branch('list', tree.state[level]['list'], false)
    out = out .. template.branch('field', tree.state[level]['field'], true)
  end
  return out
end

---
function template.print(text)
  if options.channel == 'log' or options.channel == 'tex' then
    output_file:write(text)
  else
    io.write(text)
  end
end

-- \subsubsection{tree --- Build the node tree}

---
function tree.format_field(head, field)
  local out = ''
-- Character "0" should be printed in a tree, because in TeX fonts the
-- 0 slot usually has a symbol.
  if not head[field] or (head[field] == 0 and field ~= "char") then
    return ''
  end

  if options.verbosity < 2 and
    -- glyph
    field == 'font' or
    field == 'left' or
    field == 'right' or
    field == 'uchyph' or
    -- hlist
    field == 'dir' or
    field == 'glue_order' or
    field == 'glue_sign' or
    field == 'glue_set' or
    -- glue
    field == 'stretch_order' then
    return ''
  elseif options.verbosity < 3 and
    field == 'prev' or
    field == 'next' or
    field == 'id'
  then
    return ''
  end

  if field == 'prev' or field == 'next' then
    out = node_extended.node_id(head[field])
  elseif field == 'subtype' then
    out = template.underscore(node_extended.subtype(head))
  elseif
    field == 'width' or
    field == 'height' or
    field == 'depth' or
    field == 'kern' or
    field == 'shift' then
    out = template.length(head[field])
  elseif field == 'char' then
    out = template.char(head[field])
  elseif field == 'glue_set' then
    out = template.round(head[field])
  elseif field == 'stretch' or field == 'shrink' then
    out = template.fill(head[field], head[field .. '_order'], field)
  else
    out = tostring(head[field])
  end

  return template.key_value(field, out)
end

---
-- Attributes are key/value number pairs. They are printed as an inline
-- list. The attribute |0| with the value |0| is skipped because this
-- attribute is in every node by default.
function tree.format_attributes(head)
  if not head then
    return ''
  end
  local out = ''
  local attr = head.next
  while attr do
    if attr.number ~= 0 or (attr.number == 0 and attr.value ~= 0) then
      out = out .. tostring(attr.number) .. '=' .. tostring(attr.value) .. ' '
    end
    attr = attr.next
  end
  return out
end

---
-- |level| is a integer beginning with 1. The variable |connection_type|
-- is a string, which can be either |list| or |field|. The variable
-- |connection_state| is a string, which can be either |continue| or
-- |stop|.
function tree.set_state(level, connection_type, connection_state)
  if not tree.state[level] then
    tree.state[level] = {}
  end
  tree.state[level][connection_type] = connection_state
end

---
function tree.analyze_fields(fields, level)
  local max = 0
  local connection_state = ''
  for _ in pairs(fields) do
    max = max + 1
  end
  local count = 0
  for field_name, recursion_node in pairs(fields) do
    count = count + 1
    if count == max then
      connection_state = 'stop'
    else
      connection_state = 'continue'
    end
    tree.set_state(level, 'field', connection_state)
    template.print(
      template.node_begin() ..
      template.branches(level, 'field') ..
      template.key_value(field_name) ..
      template.node_end() ..
      template.new_line()
    )
    tree.analyze_list(recursion_node, level + 1)
  end
end

---
function tree.analyze_node(head, level)
  local connection_state
  local out = ''
  if head.next then
    connection_state = 'continue'
  else
    connection_state = 'stop'
  end
  tree.set_state(level, 'list', connection_state)
  out = template.branches(level, 'list')
    .. template.type(node.type(head.id), head.id)
  if options.verbosity > 1 then
    out = out .. template.key_value('no', node_extended.node_id(head))
  end
-- We store the attributes output to append it to the field list.
  local attributes
-- We store fields which are nodes for later treatment.
  local fields = {}
  for field_id, field_name in pairs(node.fields(head.id, head.subtype)) do
    if field_name == 'attr' then
      attributes = tree.format_attributes(head.attr)
    elseif field_name ~= 'next' and      field_name ~= 'prev' and
      node.is_node(head[field_name]) then
      fields[field_name] = head[field_name]
    else
      out = out .. tree.format_field(head, field_name)
    end
  end
-- Append the attributes output if available
  if attributes ~= '' then
    out = out .. template.key_value('attr', attributes, 'blue')
  end

  template.print(
    template.node_begin() ..
    out ..
    template.node_end() ..
    template.new_line()
  )

  local property = node.getproperty(head)
  if property then
    template.print(
      template.node_begin() ..
      template.branches(level, 'field') ..
      '  ' ..
      template.colored_string('properties:', 'blue') .. ' ' ..
      template.table_inline(property) ..
      template.node_end() ..
      template.new_line()
    )
  end

  tree.analyze_fields(fields, level)
end

---
function tree.analyze_list(head, level)
  while head do
    tree.analyze_node(head, level)
    head = head.next
  end
end

---
function tree.analyze_callback(head)
  tree.analyze_list(head, 1)
  template.print(template.line('short') .. template.new_line())
end

-- \subsubsection{callbacks --- Callback wrapper}

---
function callbacks.contribute_filter(extrainfo)
  template.callback('contribute_filter', {extrainfo = extrainfo})
  return true
end

---
function callbacks.buildpage_filter(extrainfo)
  template.callback('buildpage_filter', {extrainfo = extrainfo})
  return true
end

---
function callbacks.pre_linebreak_filter(head, groupcode)
  template.callback('pre_linebreak_filter', {groupcode = groupcode})
  tree.analyze_callback(head)
  return true
end

---
function callbacks.linebreak_filter(head, is_display)
  template.callback('linebreak_filter', {is_display = is_display})
  tree.analyze_callback(head)
  return true
end

---
-- TODO: Fix return values, page output
function callbacks.append_to_vlist_filter(head, locationcode, prevdepth, mirrored)
  local variables = {
    locationcode = locationcode,
    prevdepth = prevdepth,
    mirrored = mirrored,
  }
  template.callback('append_to_vlist_filter', variables)
  tree.analyze_callback(head)
  return true
end

---
function callbacks.post_linebreak_filter(head, groupcode)
  template.callback('post_linebreak_filter', {groupcode = groupcode})
  tree.analyze_callback(head)
  return true
end

---
function callbacks.hpack_filter(head, groupcode, size, packtype, direction, attributelist)
  local variables = {
    groupcode = groupcode,
    size = size,
    packtype = packtype,
    direction = direction,
    attributelist = attributelist,
  }
  template.callback('hpack_filter', variables)
  tree.analyze_callback(head)
  return true
end

---
function callbacks.vpack_filter(head, groupcode, size, packtype, maxdepth, direction, attributelist)
  local variables = {
    groupcode = groupcode,
    size = size,
    packtype = packtype,
    maxdepth = template.length(maxdepth),
    direction = direction,
    attributelist = attributelist,
  }
  template.callback('vpack_filter', variables)
  tree.analyze_callback(head)
  return true
end

---
function callbacks.hpack_quality(incident, detail, head, first, last)
  local variables = {
    incident = incident,
    detail = detail,
    first = first,
    last = last,
  }
  template.callback('hpack_quality', variables)
  tree.analyze_callback(head)
end

---
function callbacks.vpack_quality(incident, detail, head, first, last)
  local variables = {
    incident = incident,
    detail = detail,
    first = first,
    last = last,
  }
  template.callback('vpack_quality', variables)
  tree.analyze_callback(head)
end

---
function callbacks.process_rule(head, width, height)
  local variables = {
    width = width,
    height = height,
  }
  template.callback('process_rule', variables)
  tree.analyze_callback(head)
  return true
end

---
function callbacks.pre_output_filter(head, groupcode, size, packtype, maxdepth, direction)
  local variables = {
    groupcode = groupcode,
    size = size,
    packtype = packtype,
    maxdepth = maxdepth,
    direction = direction,
  }
  template.callback('pre_output_filter', variables)
  tree.analyze_callback(head)
  return true
end

---
function callbacks.hyphenate(head, tail)
  template.callback('hyphenate')
  template.print('head:')
  tree.analyze_callback(head)
  template.print('tail:')
  tree.analyze_callback(tail)
end

---
function callbacks.ligaturing(head, tail)
  template.callback('ligaturing')
  template.print('head:')
  tree.analyze_callback(head)
  template.print('tail:')
  tree.analyze_callback(tail)
end

---
function callbacks.kerning(head, tail)
  template.callback('kerning')
  template.print('head:')
  tree.analyze_callback(head)
  template.print('tail:')
  tree.analyze_callback(tail)
end

---
function callbacks.insert_local_par(local_par, location)
  template.callback('insert_local_par', {location = location})
  tree.analyze_callback(local_par)
  return true
end

---
function callbacks.mlist_to_hlist(head, display_type, need_penalties)
  local variables = {
    display_type = display_type,
    need_penalties = need_penalties,
  }
  template.callback('mlist_to_hlist', variables)
  tree.analyze_callback(head)
  return node.mlist_to_hlist(head, display_type, need_penalties)
end

-- \subsubsection{export --- Exported functions}

---
function export.set_option(key, value)
  if not options then
    options = {}
  end
  if key == 'verbosity' or key == 'decimalplaces' then
    options[key] = tonumber(value)
  else
    options[key] = value
  end
end

---
-- a table.
function export.set_options(opts)
  if not options then
    options = {}
  end
  for key, value in pairs(opts) do
    export.set_option(key, value)
  end
end

---
function export.get_option(key)
  if not options then
    options = {}
  end
  if options[key] then
    return options[key]
  end
end

---
function export.get_callback_name(alias)
  if alias == 'contribute' or alias == 'contributefilter' then
    return 'contribute_filter'

  elseif alias == 'buildpage' or alias == 'buildpagefilter' then
    return 'buildpage_filter'

  elseif alias == 'preline' or alias == 'prelinebreakfilter' then
    return 'pre_linebreak_filter'

  elseif alias == 'line' or alias == 'linebreakfilter' then
    return 'linebreak_filter'

  elseif alias == 'append' or alias == 'appendtovlistfilter' then
    return 'append_to_vlist_filter'

  elseif alias == 'postline' or alias == 'postlinebreakfilter' then
    return 'post_linebreak_filter'

  elseif alias == 'hpack' or alias == 'hpackfilter' then
    return 'hpack_filter'

  elseif alias == 'vpack' or alias == 'vpackfilter' then
    return 'vpack_filter'

  elseif alias == 'hpackq' or alias == 'hpackquality' then
    return 'hpack_quality'

  elseif alias == 'vpackq' or alias == 'vpackquality' then
    return 'vpack_quality'

  elseif alias == 'process' or alias == 'processrule' then
    return 'process_rule'

  elseif alias == 'preout' or alias == 'preoutputfilter' then
    return 'pre_output_filter'

  elseif alias == 'hyph' or alias == 'hyphenate' then
    return 'hyphenate'

  elseif alias == 'liga' or alias == 'ligaturing' then
    return 'ligaturing'

  elseif alias == 'kern' or alias == 'kerning' then
   return 'kerning'

  elseif alias == 'insert' or alias == 'insertlocalpar' then
    return 'insert_local_par'

  elseif alias == 'mhlist' or alias == 'mlisttohlist' then
    return 'mlist_to_hlist'

  else
    return 'post_linebreak_filter'
  end
end

---
function export.register(cb)
  if options.engine == 'lualatex' then
    luatexbase.add_to_callback(cb, callbacks[cb], 'nodetree')
  else
    id, error = callback.register(cb, callbacks[cb])
  end
end

---
function export.register_callbacks()
  if options.channel == 'log' or options.channel == 'tex' then
    output_file = io.open(tex.jobname .. '_nodetree.' .. options.channel, 'a')
  end
  for alias in string.gmatch(options.callback, '([^,]+)') do
    export.register(export.get_callback_name(alias))
  end
end

---
function export.unregister(cb)
  if options.engine == 'lualatex' then
    luatexbase.remove_from_callback(cb, 'nodetree')
  else
    id, error = callback.register(cb, nil)
  end
end

---
function export.unregister_callbacks()
  for alias in string.gmatch(options.callback, '([^,]+)') do
    export.unregister(export.get_callback_name(alias))
  end
end

---
function export.execute()
  local c = export.get_callback()
  if options.engine == 'lualatex' then
    luatexbase.add_to_callback(c, callbacks.post_linebreak_filter, 'nodetree')
  else
    id, error = callback.register(c, callbacks.post_linebreak_filter)
  end
end

---
function export.compile_include(tex_markup)
  example_counter = example_counter + 1
  local filename_tex = tex.jobname .. '_' .. example_counter .. '_nodetree.tex'
  output_file = io.open(filename_tex, 'w')
  local prefix = '%!TEX program = lualatex\n' ..
                 '\\documentclass{article}\n' ..
                 '\\usepackage[channel=tex]{nodetree}\n' ..
                 '\\begin{document}\n'
  local suffix = '\n\\end{document}'
  output_file:write(prefix .. tex_markup .. suffix)
  output_file:close()
  local status, error = os.spawn({ 'lualatex', filename_tex })
  print(status)
  print(error)
end

---
function export.analyze(head)
  template.print(template.new_line())
  tree.analyze_list(head, 1)
end

---
function export.print(head, opts)
  if opts and type(opts) == 'table' then
    export.set_options(opts)
  end
  template.print(template.new_line())
  tree.analyze_list(head, 1)
end

---
function export.format_dim(sp)
  return template.length(sp)
end

return export
