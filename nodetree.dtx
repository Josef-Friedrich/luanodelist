% \iffalse meta-comment
%
% Copyright (C) 2016-2020 by Josef Friedrich <josef@friedrich.rocks>
% ----------------------------------------------------------------------
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, either version 1.3 of this license
% or (at your option) any later version.  The latest version of this
% license is in:
%
%   http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Josef Friedrich.
%
% This work consists of the files nodetree.dtx and nodetree.ins
% and the derived filebase nodetree.sty and nodetree.lua.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{nodetree.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{nodetree}
%<*package>
    [2016/07/18 v1.2 Visualize node lists in a tree view]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage{paralist,fontspec,graphicx,fancyvrb}
\usepackage[
  colorlinks=true,
  linkcolor=red,
  filecolor=red,
  urlcolor=red,
]{hyperref}
\usepackage[theme=molokai,thememode=dark,documentationmode]{nodetree}
\EnableCrossrefs
\CodelineIndex
\RecordChanges

\usepackage{minted}
\usemintedstyle{colorful}
\BeforeBeginEnvironment{minted}{\begin{mdframed}[backgroundcolor=gray!3]}
\AfterEndEnvironment{minted}{\end{mdframed}}
\setminted{
  breaklines=true,
  fontsize=\footnotesize,
}

\def\nodetreelua#1{\texttt{\scantokens{\catcode`\_=12\relax#1}}}

\def\secref#1{(\rightarrow\ \ref{#1})}

\newcommand{\TmpGraphics}[1]{
  \noindent
  \includegraphics[scale=0.4]{graphics/#1}
}


\newcommand{\TmpExample}[1]{
\begin{nodetreeexample}
\input{examples/#1_nodetree.tex}
\end{nodetreeexample}
}

\newcommand{\TmpVerbExample}[1]{
\VerbatimInput[frame=single,fontsize=\footnotesize,firstline=4]{examples/#1.tex}
\TmpExample{#1}
}

\DefineVerbatimEnvironment{code}{Verbatim}
{
  frame=single,
  fontsize=\footnotesize,
}

\newcommand{\TmpLuaFunction}[1]{
  \marginpar{%
    \raggedleft%
    \MacroFont%
    \texttt{%
      \scantokens{\catcode`\_=12\relax#1}%
    }%
  }%
}

\begin{document}

\providecommand*{\url}{\texttt}
\GetFileInfo{nodetree.dtx}
\title{The \textsf{nodetree} package}
\author{%
  Josef Friedrich\\%
  \url{josef@friedrich.rocks}\\%
  \href{https://github.com/Josef-Friedrich/nodetree}{github.com/Josef-Friedrich/nodetree}%
}
\date{\fileversion~from \filedate}

\maketitle

\begin{nodetreeexample}[fontsize=\footnotesize]
\input{examples/packagename_nodetree.tex}
\end{nodetreeexample}

\newpage

\tableofcontents

\newpage

%-----------------------------------------------------------------------
% Abstract
%-----------------------------------------------------------------------

\section{Abstract}

|nodetree| is a development package that visualizes the structure of
node lists. |nodetree| shows its debug informations in the consoles’
output when you compile a Lua\TeX{} file. It uses a similar visual
representation for node lists as the UNIX |tree| command does for a
folder tree.

Node lists are the main building blocks of each document generated by
the \TeX{} engine \emph{Lua\TeX}. The package |nodetree| doesn‘t change
the rendered document. The tree view can only be seen when using a
terminal to generate the document.

|nodetree| is inspired by a
\href{https://gist.github.com/pgundlach/556247}
{gist from Patrick Gundlach}.

%-----------------------------------------------------------------------
% Usage
%-----------------------------------------------------------------------

\section{Usage}

The package |nodetree| has three usage scenarios.
It can be used as a standalone Lua module, as a plain Lua\TeX{} or a
Lua\LaTeX{} package.

%%
%
%%

\subsection{As a plain Lua\TeX{} package}

Run |luatex luatex-test.tex| for example to list the nodes using
Lua\TeX{}.

\begin{minted}{latex}
\input{nodetree.tex}
\nodetreeregister{postline}

Lorem ipsum dolor.
\bye
\end{minted}

%%
%
%%

\subsection{As a Lua\LaTeX{} package}

Or run |lualatex lualatex-test.tex| to show a node tree using
Lua\LaTeX{}. In Lua\LaTeX{} you can omit |\nodetreeregister{postline}|.
|\usepackage{nodetree}| registers automatically the
|post_linebreak_filter|. If you don’t want debug the
|post_linebreak_filter| use |\nodetreeunregister{postline}|.

\begin{minted}{latex}
\documentclass{article}
\usepackage{nodetree}

\begin{document}
Lorem ipsum dolor.
\end{document}
\end{minted}

%%
% inside Lua code
%%

\subsection{As a Lua module}

Import the Lua module of the package inside
\mintinline{latex}{\directlua{}}
with this command:
\mintinline{lua}{local nodetree = require('nodetree')}.
Then use the Lua function \mintinline{lua}{nodetree.print(head, options)} to debug nodes
inside your Lua code.

\begin{minted}{lua}
local nodetree = require('nodetree')

local rule1 = node.new('rule')
rule1.width  = 20 * 65536
rule1.height = 10 * 65536
rule1.depth  = 10 * 65536
nodetree.print(vbox)
\end{minted}

The function \mintinline{lua}{nodetree.print()} takes as a second
argument a Lua table to configure the output.

\begin{minted}{lua}
nodetree.print(vbox, { verbosity = 2, unit = 'cm' })
\end{minted}

This are the default options:

\begin{minted}{lua}
options =  {
  verbosity = 1,
  callback = 'postlinebreak',
  engine = 'luatex',
  color = 'colored',
  decimalplaces = 2,
  unit = 'pt',
  channel = 'term'
}
\end{minted}

The following code snippet demonstrates the usage in Lua\TeX{}.
|head| is the current node.

\begin{minted}{latex}
  \directlua{
  local nodetree = require('nodetree')
  local test = function (head)
    nodetree.analyze(head)
  end
  callback.register('post_linebreak_filter', test)
}

Lorem ipsum dolor.
\bye
\end{minted}

This example illustrates how the function has to be applied in
Lua\LaTeX{}.

\begin{minted}{latex}
\documentclass{article}
\usepackage{nodetree}

\begin{document}

\directlua{
  local test = function (head)
    nodetree.analyze(head)
  end
  luatexbase.add_to_callback('post_linebreak_filter', test, 'test')
}

Lorem ipsum dolor.
\end{document}
\end{minted}

%-----------------------------------------------------------------------
% Macros
%-----------------------------------------------------------------------

\section{Macros}

%%
% \nodetreeregister
%%

\subsection{\cmd{\nodetreeregister}}

\DescribeMacro{\nodetreeregister}
\cmd{\nodetreeregister}\marg{callbacks}: The argument \marg{callbacks}
takes a comma separated list of callback aliases as described in
\secref{sec:option-callback}.

%%
% \nodetreeunregister
%%

\subsection{\cmd{\nodetreeunregister}}

\DescribeMacro{\nodetreeunregister}
\cmd{\nodetreeunregister}\marg{callbacks}: The argument \marg{callbacks}
takes a comma separated list of callback aliases as described in
\secref{sec:option-callback}.

%%
% \nodetreeoption
%%

\subsection{\cmd{\nodetreeoption}}

\DescribeMacro{\nodetreeoption}
\cmd{\nodetreeoption}\oarg{option}\marg{value}: \secref{sec:options}
This macro sets the option \oarg{option} to the value \marg{value}.

%%
% \nodetreeset
%%

\subsection{\cmd{\nodetreeset}}

\DescribeMacro{\nodetreeset}
\cmd{\nodetreeset}\marg{kv-options}:
This macro can only be used in Lua\LaTeX{}. \marg{kv-options} are key
value pairs.

\begin{code}
\nodetreeset{color=no,callbacks={hpack,vpack},verbosity=2}
\end{code}

%-----------------------------------------------------------------------
% Options
%-----------------------------------------------------------------------

\section{Options}
\label{sec:options}

%%
% callback
%%

\subsection{Option \texttt{callback}}
\label{sec:option-callback}

The option |callback| is the most important setting of the package. You
have to specify one alias to select the |callback|. Because of the
underscores the callback name contains it can not set by its technical
name (\rightarrow{} Figure \ref{fig:callback}).

This macros process callback options:
\cmd{\nodetreeregister}\marg{callbacks},
\cmd{\nodetreeunregister}\marg{callbacks},
\cmd{\nodetreeset}\marg{callback=<callbacks>} and
\cmd{\usepackage}\oarg{callback=<callbacks>}\marg{nodetree}.

Use commas to specify mulitple callbacks. Avoid using whitespaces:

\begin{code}
\nodetreeregister{preline,line,postline}
\end{code}

Wrap your callback aliases in curly braces for the macro |\nodetreeset|:

\begin{code}
\nodetreeset{callback={preline,line,postline}}
\end{code}

The same applies for the macro |\usepackage|:

\begin{code}
\usepackage{callback={preline,line,postline}}
\end{code}

%%
% Tabular callbacks
%%

\newcommand{\nodetreecallback}[3]{
  \nodetreelua{#1} & \nodetreelua{#2} & \nodetreelua{#3} \\
}

\begin{figure}

\noindent
\begin{tabular}{lll}
\textbf{Alias (short)} & \textbf{Alias (longer)} & \textbf{Callback} \\
\nodetreecallback{contribute}{contributefilter}{contribute_filter}
\nodetreecallback{buildpage}{buildpagefilter}{buildpage_filter}
\nodetreecallback{preline}{prelinebreakfilter}{pre_linebreak_filter}
\nodetreecallback{line}{linebreakfilter}{linebreak_filter}
\nodetreecallback{append}{appendtovlistfilter}{append_to_vlist_filter}
\nodetreecallback{postline}{postlinebreakfilter}{post_linebreak_filter}
\nodetreecallback{hpack}{hpackfilter}{hpack_filter}
\nodetreecallback{vpack}{vpackfilter}{vpack_filter}
\nodetreecallback{hpackq}{hpackquality}{hpack_quality}
\nodetreecallback{vpackq}{vpackquality}{vpack_quality}
\nodetreecallback{process}{processrule}{process_rule}
\nodetreecallback{preout}{preoutputfilter}{pre_output_filter}
\nodetreecallback{hyph}{hyphenate}{hyphenate}
\nodetreecallback{liga}{ligaturing}{ligaturing}
\nodetreecallback{kern}{kerning}{kerning}
\nodetreecallback{insert}{insertlocalpar}{insert_local_par}
\nodetreecallback{mhlist}{mlisttohlist}{mlist_to_hlist}
\end{tabular}

\caption{The callback aliases}
\label{fig:callback}
\end{figure}

%%
% channel
%%

\subsection{Option \texttt{channel}}
\label{sec:option-channel}

You can select the debug output channel with this option. The default
value for the option |channel| is |term| which displays the node tree in
the current terminal. Specify |log| and the package creates a log file
named |jobname_nodetree.log|. |jobname| is the name of your file you
want to debug.

%%
% verbosity
%

\subsection{Option \texttt{verbosity}}

Higher integer values result in a more verbose output. The default value
for this options is |1|. At the moment only verbosity level |2| is
implemented.

\subsubsection{Example \texttt{verbosity=1}}

\nodetreeterminalemulator{examples/option_verbosity-1}

\subsubsection{Example \texttt{verbosity=2}}

\nodetreeterminalemulator{examples/option_verbosity-2}

\subsubsection{Example \texttt{verbosity=3}}

\nodetreeterminalemulator{examples/option_verbosity-3}

%%
% color
%%

\subsection{Option \texttt{color}}

The default option for |color| is |colored|. Use any other string (for
example |none| or |no|) to disable the colored terminal output of the
package.

\begin{code}
\usepackage[color=no]{nodetree}
\end{code}

%%
% unit
%%

\subsection{Option \texttt{unit}}

The option |unit| sets the length unit to display all length values of
the nodes. The default option for |unit| is |pt|. See figure
\ref{fig:fixed-units} and \ref{fig:relative-units} for possible values.

\begin{figure}
\begin{tabular}{lp{10cm}}
\textbf{Unit} &
\textbf{Description} \\

pt &
Point 1/72.27 inch. The conversion to metric units, to two decimal
places, is 1 point = 2.85 mm = 28.45 cm. \\

pc &
Pica, 12 pt \\

in &
Inch, 72.27 pt \\

bp &
Big point, 1/72 inch. This length is the definition of a point in
PostScript and many desktop publishing systems. \\

cm &
Centimeter \\

mm &
Millimeter \\

dd &
Didot point, 1.07 pt \\

cc &
Cicero, 12 dd \\

sp &
Scaled point, 1/65536 pt \\
\end{tabular}
\caption{Fixed units}
\label{fig:fixed-units}
\end{figure}

\begin{figure}
\begin{tabular}{lp{10cm}}
\textbf{Unit} &
\textbf{Description} \\

ex &
x-height of the current font \\

em &
Width of the capital letter M \\
\end{tabular}
\caption{Relative units}
\label{fig:relative-units}
\end{figure}


\nodetreeterminalemulator{examples/option_unit-pt}
\nodetreeterminalemulator{examples/option_unit-sp}
\nodetreeterminalemulator{examples/option_unit-cm}

%%
% decimalplaces
%%

\subsection{Option \texttt{decimalplaces}}

The options |decimalplaces| sets the number of decimal places for some
node fields.

\begin{code}
\nodetreeoption[decimalplaces]{4}
\end{code}

gets

\begin{code}
├─GLYPH char: "a"; width: 5pt; height: 4.3055pt;
\end{code}

If |decimalplaces| is set to |0| only integer values are shown.

\begin{code}
├─GLYPH char: "a"; width: 5pt; height: 4pt;
\end{code}

%%
% theme and thememode
%%

\newcommand{\TmpExampleTheme}[2]{
  \subsubsection{Example \texttt{theme=#1} \texttt{thememode=#2}}
  \nodetreeterminalemulator[theme=#1,thememode=#2]{examples/minimal}
}

\subsection{Option \texttt{theme} and \texttt{thememode}}

% bw
\TmpExampleTheme{bwdark}{dark}
\TmpExampleTheme{bwlight}{light}

% terminalapp
\TmpExampleTheme{terminalapp}{dark}
\TmpExampleTheme{terminalapp}{light}

% xterm
\TmpExampleTheme{xterm}{dark}
\TmpExampleTheme{xterm}{light}

% smyck
\TmpExampleTheme{smyck}{dark}
\TmpExampleTheme{smyck}{light}

% molokai
\TmpExampleTheme{molokai}{dark}
\TmpExampleTheme{molokai}{light}

% monokaisoda
\TmpExampleTheme{monokaisoda}{dark}
\TmpExampleTheme{monokaisoda}{light}

\nodetreereset

%%
% font
%%

\subsection{Option \texttt{font}}

\nodetreeset{fontsize=\small}

\newcommand{\TmpExampleFont}[1]{
  \subsubsection{Example \texttt{font=\{#1\}}}
  \nodetreeterminalemulator[font={#1}]{examples/minimal}
}

\TmpExampleFont{FreeMono}
\TmpExampleFont{Liberation Mono}
\TmpExampleFont{DejaVu Sans Mono}
\TmpExampleFont{Ubuntu Mono}


\nodetreereset

%%
% fontsize
%%

\subsection{Option \texttt{fontsize}}

\string\small

\nodetreeterminalemulator[fontsize=\small]{examples/minimal}

\string\tiny

\nodetreeterminalemulator[fontsize=\tiny]{examples/minimal}

\nodetreereset

%-----------------------------------------------------------------------
% Visual tree structure
%-----------------------------------------------------------------------

\section{Visual tree structure}

%%
% Two different connections
%%

\subsection{Two different connections}

Nodes in Lua\TeX{} are connected. The |nodetree| package distinguishs
between the |list| and |field| connections.

\begin{itemize}
 \item |list|: Nodes, which are double connected by |next| and
       |previous| fields.
 \item |field|: Connections to nodes by other fields than |next| and
       |previous| fields, e. g. |head|, |pre|.
\end{itemize}

%%
% Unicode characters
%%

\subsection{Unicode characters to show the tree view}

\renewcommand{\arraystretch}{1.5}

The package |nodetree| uses the unicode box drawing symbols. Your
default terminal font should contain this characters to obtain the tree
view. Eight box drawing characters are necessary.


{
\fontspec{DejaVu Sans Mono}
\noindent
\begin{tabular}{lcl}
\textbf{Code} & \textbf{Character} & \textbf{Name} \\
U+2500 & ─ & BOX DRAWINGS LIGHT HORIZONTAL \\
U+2502 & │ & BOX DRAWINGS LIGHT VERTICAL \\
U+2514 & └ & BOX DRAWINGS LIGHT UP AND RIGHT \\
U+251C & ├ & BOX DRAWINGS LIGHT VERTICAL AND RIGHT \\
U+2550 & ═ & BOX DRAWINGS DOUBLE HORIZONTAL \\
U+2551 & ║ & BOX DRAWINGS DOUBLE VERTICAL \\
U+255A & ╚ & BOX DRAWINGS DOUBLE UP AND RIGHT \\
U+2560 & ╠ & BOX DRAWINGS DOUBLE VERTICAL AND RIGHT \\
\end{tabular}
}

\noindent
For |list| connections \emph{light} characters are shown.

{
\setmonofont{DejaVu Sans Mono}
\begin{code}
│ │
│ ├─list1
│ └─list2
└─list3
\end{code}
}

\noindent
|field| connections are visialized by \emph{Double} characters.

{
\setmonofont{DejaVu Sans Mono}
\begin{code}
║ ║
║ ╠═field1
║ ╚═field2
╚═field3
\end{code}
}

%-----------------------------------------------------------------------
% Examples
%-----------------------------------------------------------------------

\section{Examples}

%%
% packagename
%%

\subsection{The node list of the package name}

\TmpVerbExample{packagename}

%%
% math
%%

\subsection{The node list of a mathematical formula}

\TmpVerbExample{math}

%%
% ligatures
%%

\subsection{The node list of the word \emph{Office}}

The characters \emph{ffi} are deeply nested in a discretionary node.

\TmpVerbExample{ligatures}

%-----------------------------------------------------------------------
% Node types
%-----------------------------------------------------------------------

\subsection{Node types}

\newcommand{\TmpNodeTypeSub}[4]{
  \subsubsection{Type: #1(#2) Subtype: #3(#4)}
  \TmpVerbExample{#2#1#4#3}
}

\newcommand{\TmpNodeType}[2]{
  \subsubsection{Type: #1(#2)}
  \TmpVerbExample{#2#1}
}

\TmpNodeTypeSub{hlist}{0}{line}{1}
\TmpNodeTypeSub{hlist}{0}{box}{2}
\TmpNodeTypeSub{hlist}{0}{indent}{3}
\TmpNodeType{vlist}{1}
\TmpNodeType{rule}{2}
\TmpNodeType{mark}{4}
\TmpNodeTypeSub{disc}{7}{discretionary}{0}
\TmpNodeTypeSub{disc}{7}{regular}{3}
\TmpNodeTypeSub{whatsit}{8}{pdfaction}{22}
\TmpNodeTypeSub{whatsit}{8}{pdfcolorstack}{28}
\TmpNodeTypeSub{glue}{12}{baselineskip}{2}
\TmpNodeTypeSub{glue}{12}{parskip}{3}
\TmpNodeTypeSub{glue}{12}{spaceskip}{13}
\TmpNodeTypeSub{glue}{12}{leaders}{100}
\TmpNodeTypeSub{glue}{12}{cleaders}{101}
\TmpNodeTypeSub{glue}{12}{xleaders}{102}
\TmpNodeTypeSub{kern}{13}{userkern}{0}
\TmpNodeTypeSub{kern}{13}{fontkern}{1}
\TmpNodeTypeSub{kern}{13}{accentkern}{2}
\TmpNodeTypeSub{kern}{13}{italiccorrection}{3}
\TmpNodeType{penalty}{14}
\TmpNodeType{glyph}{29}
\TmpNodeType{attribute}{38}
\TmpNodeType{attributelist}{40}

%-----------------------------------------------------------------------
% Index
%-----------------------------------------------------------------------

  \DocInput{nodetree.dtx}
  \pagebreak
  \PrintChanges
  \pagebreak
  \PrintIndex
\end{document}
%</driver>
%<*readme>

![nodetree](https://raw.githubusercontent.com/Josef-Friedrich/nodetree/master/graphics/packagename.png)

# Abstract

`nodetree` is a development package that visualizes the structure of
node lists. `nodetree` shows its debug informations in the consoles’
output when you compile a LuaTeX file. It uses a similar visual
representation for node lists as the UNIX `tree` command uses for a
folder structure.

Node lists are the main building blocks of each document generated by
the TeX engine LuaTeX. The package `nodetree` doesn‘t change
the rendered document. The tree view can only be seen when using a
terminal to generate the document.

`nodetree` is inspired by a
[gist from Patrick Gundlach](https://gist.github.com/pgundlach/556247).

# License

Copyright (C) 2016-2020 by Josef Friedrich <josef@friedrich.rocks>
------------------------------------------------------------------------
This work may be distributed and/or modified under the conditions of
the LaTeX Project Public License, either version 1.3 of this license
or (at your option) any later version.  The latest version of this
license is in:

  http://www.latex-project.org/lppl.txt

and version 1.3 or later is part of all distributions of LaTeX
version 2005/12/01 or later.

# CTAN

Since July 2016 the cloze package is included in the Comprehensive TeX
Archive Network (CTAN).

* TeX archive: http://mirror.ctan.org/tex-archive/macros/luatex/generic/nodetree
* Package page: http://www.ctan.org/pkg/nodetree

# Repository

https://github.com/Josef-Friedrich/nodetree

# Installation

Get source:

    git clone git@github.com:Josef-Friedrich/nodetree.git
    cd nodetree

Compile:

    make

or manually:

    luatex nodetree.ins
    lualatex nodetree.dtx
    makeindex -s gglo.ist -o nodetree.gls nodetree.glo
    makeindex -s gind.ist -o nodetree.ind nodetree.idx
    lualatex nodetree.dtx

# Examples

## The node list of the package name

```latex
\documentclass{article}
\usepackage{nodetree}
\begin{document}
nodetree
\end{document}
```

![nodetree](graphics/packagename.png)

## The node list of a mathematical formula

```latex
\documentclass{article}
\usepackage[callback={mhlist}]{nodetree}
\begin{document}
\[\left(a\right)\left[\frac{b}{a}\right]=a\,\]
\end{document}
```

![nodetree](https://raw.githubusercontent.com/Josef-Friedrich/nodetree/master/graphics/math.png)

## The node list of the word 'Office'

The characters 'ffi' are deeply nested in a discretionary node.

```latex
\documentclass{article}
\usepackage{nodetree}
\begin{document}
Office
\end{document}
```

![nodetree](https://raw.githubusercontent.com/Josef-Friedrich/nodetree/master/graphics/ligatures.png)

# Development

First delete the stable version installed by TeX Live. Because the
package `nodetree` belongs to the collection `collection-latexextra`, the
option  `--force` must be used to delete the package.

    tlmgr remove --force nodetree

## Deploying a new version

Update the version number in the file `nodetree.dtx` on this locations:

### In the markup for the file `nodetree.sty` (approximately at the line number 30)

    %<*package>
    [2016/07/18 v1.2 Visualize node lists in a tree view]
    %<*package>

### In the markup for the package documentation (approximately at the line number 750)

Add a changes entry:

```latex
\changes{v1.2}{2020/05/20}{...}
```

### In the markup for the file `nodetree.lua` (approximately at the line number 900)

```lua
if not modules then modules = { } end modules ['nodetree'] = {
  version   = '1.2'
}
```

### Update the copyright year:

```
sed -i 's/(C) 2016-2020/(C) 2016-2021/g' nodetree.ins
sed -i 's/(C) 2016-2020/(C) 2016-2021/g' nodetree.dtx
```

### Command line tasks:

```
git tag v1.4
make
make ctan
```

%</readme>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.1}{2015/06/16}{Converted to DTX file}
% \changes{v1.0}{2016/07/07}{Inital release}
% \changes{v1.1}{2016/07/13}{Fix the registration of same callbacks}
% \changes{v1.2}{2016/07/18}{Fix difference between README.md in the upload and that from nodetree.dtx}
%
% \DoNotIndex{\newcommand,\newenvironment,\def,\directlua}
%
% \StopEventually{}
% \pagebreak
% \section{Implementation}
%
% \iffalse
%<*tex>
% \fi
% \MacroTopsep = 10pt plus 2pt minus 2pt
% \MacrocodeTopsep = 10pt plus 1.2pt minus 1pt
% \makeatletter
% \c@CodelineNo 25 \relax
% \makeatother
%
% \subsection{The file \tt{nodetree.tex}}
%
%    \begin{macrocode}
\directlua{
  nodetree = require('nodetree')
  nodetree.set_option('engine', 'luatex')
}
%    \end{macrocode}
%
% \begin{macro}{\nodetreeoption}
%    \begin{macrocode}
\def\nodetreeoption[#1]#2{
  \directlua{
    nodetree.set_option('#1', '#2')
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\nodetreeregister}
%    \begin{macrocode}
\def\nodetreeregister#1{
  \directlua{
    nodetree.set_option('callback', '#1')
    nodetree.register_callbacks()
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\nodetreeunregister}
%    \begin{macrocode}
\def\nodetreeunregister#1{
  \directlua{
    nodetree.set_option('callback', '#1')
    nodetree.unregister_callbacks()
  }
}
%    \end{macrocode}
% \end{macro}
%
% \iffalse
%</tex>
%<*package>
% \fi
% \makeatletter
% \c@CodelineNo 25 \relax
% \makeatother
%
% \subsection{The file \tt{nodetree.sty}}
%
%    \begin{macrocode}
\input{nodetree}
\directlua{
  nodetree.set_option('engine', 'lualatex')
}
%    \end{macrocode}
%
%    \begin{macrocode}
\RequirePackage{kvoptions}
%    \end{macrocode}
%
%    \begin{macrocode}
\SetupKeyvalOptions{
  family=NT,
  prefix=NTK@
}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[term]{channel}
\define@key{NT}{channel}[]{\nodetreeoption[channel]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[postlinebreak]{callback}
\define@key{NT}{callback}[]{\nodetreeoption[callback]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[1]{verbosity}
\define@key{NT}{verbosity}[]{\nodetreeoption[verbosity]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[colored]{color}
\define@key{NT}{color}[]{\nodetreeoption[color]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[1]{unit}
\define@key{NT}{unit}[]{\nodetreeoption[unit]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[1]{decimalplaces}
\define@key{NT}{decimalplaces}[]{\nodetreeoption[decimalplaces]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[smyck]{theme}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[dark]{thememode}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[Ubuntu Mono]{font}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[\footnotesize]{fontsize}
%    \end{macrocode}
%

% Never load “heavy” packages like |mdframed| in default debug mode.
% They are way to slow.
%    \begin{macrocode}
\newif\ifdocumentationmode%
\documentationmodefalse%
\DeclareVoidOption{documentationmode}{%
  \RequirePackage{xcolor,mdframed,expl3,xparse}%
  \nodetreeoption[callback]{}%
  \documentationmodetrue%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\ProcessKeyvalOptions{NT}
\directlua{
  nodetree.register_callbacks()
}
%    \end{macrocode}
%
% \begin{macro}{\nodetreeset}
%    \begin{macrocode}
\newcommand{\nodetreeset}[1]{%
  \setkeys{NT}{#1}%
}
%    \end{macrocode}
% \end{macro}
% Begin of the documentation mode.
%    \begin{macrocode}
\ifdocumentationmode
%    \end{macrocode}
%
% \begin{macro}{\NT@colors}
%    \begin{macrocode}
\ExplSyntaxOn
\def\NT@colors{
  \str_case_e:nn{\NTK@theme}{
    {bwdark}{
      \definecolor{NTblack}{gray}{0}
      \definecolor{NTred}{gray}{1}
      \definecolor{NTgreen}{gray}{1}
      \definecolor{NTyellow}{gray}{1}
      \definecolor{NTblue}{gray}{1}
      \definecolor{NTmagenta}{gray}{1}
      \definecolor{NTcyan}{gray}{1}
      \definecolor{NTgray}{gray}{1}
      \definecolor{NTblackbright}{gray}{0}
      \definecolor{NTredbright}{gray}{1}
      \definecolor{NTgreenbright}{gray}{1}
      \definecolor{NTyellowbright}{gray}{1}
      \definecolor{NTbluebright}{gray}{1}
      \definecolor{NTmagentabright}{gray}{1}
      \definecolor{NTcyanbright}{gray}{1}
      \definecolor{NTgraybright}{gray}{1}
    }
    {bwlight}{
      \definecolor{NTblack}{gray}{0}
      \definecolor{NTred}{gray}{0}
      \definecolor{NTgreen}{gray}{0}
      \definecolor{NTyellow}{gray}{0}
      \definecolor{NTblue}{gray}{0}
      \definecolor{NTmagenta}{gray}{0}
      \definecolor{NTcyan}{gray}{0}
      \definecolor{NTgray}{gray}{1}
      \definecolor{NTblackbright}{gray}{0}
      \definecolor{NTredbright}{gray}{0}
      \definecolor{NTgreenbright}{gray}{0}
      \definecolor{NTyellowbright}{gray}{0}
      \definecolor{NTbluebright}{gray}{0}
      \definecolor{NTmagentabright}{gray}{0}
      \definecolor{NTcyanbright}{gray}{0}
      \definecolor{NTgraybright}{gray}{1}
    }
    {terminalapp}{
      \definecolor{NTblack}{RGB}{0,0,0}
      \definecolor{NTred}{RGB}{194,54,33}
      \definecolor{NTgreen}{RGB}{37,188,36}
      \definecolor{NTyellow}{RGB}{173,173,39}
      \definecolor{NTblue}{RGB}{73,46,225}
      \definecolor{NTmagenta}{RGB}{211,56,211}
      \definecolor{NTcyan}{RGB}{51,187,200}
      \definecolor{NTgray}{RGB}{203,204,205}
      \definecolor{NTblackbright}{RGB}{129,131,131}
      \definecolor{NTredbright}{RGB}{252,57,31}
      \definecolor{NTgreenbright}{RGB}{49,231,34}
      \definecolor{NTyellowbright}{RGB}{234,236,35}
      \definecolor{NTbluebright}{RGB}{88,51,255}
      \definecolor{NTmagentabright}{RGB}{249,53,248}
      \definecolor{NTcyanbright}{RGB}{20,240,240}
      \definecolor{NTgraybright}{RGB}{233,235,235}
    }
    {xterm}{
      \definecolor{NTblack}{RGB}{0,0,0}
      \definecolor{NTred}{RGB}{205,0,0}
      \definecolor{NTgreen}{RGB}{0,205,0}
      \definecolor{NTyellow}{RGB}{205,205,0}
      \definecolor{NTblue}{RGB}{0,0,238}
      \definecolor{NTmagenta}{RGB}{205,0,205}
      \definecolor{NTcyan}{RGB}{0,205,205}
      \definecolor{NTgray}{RGB}{229,229,229}
      \definecolor{NTblackbright}{RGB}{127,127,127}
      \definecolor{NTredbright}{RGB}{255,0,0}
      \definecolor{NTgreenbright}{RGB}{0,255,0}
      \definecolor{NTyellowbright}{RGB}{255,255,0}
      \definecolor{NTbluebright}{RGB}{92,92,255}
      \definecolor{NTmagentabright}{RGB}{255,0,255}
      \definecolor{NTcyanbright}{RGB}{0,255,255}
      \definecolor{NTgraybright}{RGB}{255,255,255}
    }
    {smyck}{
      \definecolor{NTblack}{HTML}{212121}
      \definecolor{NTred}{HTML}{C75646}
      \definecolor{NTgreen}{HTML}{8EB33B}
      \definecolor{NTyellow}{HTML}{D0B03C}
      \definecolor{NTblue}{HTML}{72B3CC}
      \definecolor{NTmagenta}{HTML}{C8A0D1}
      \definecolor{NTcyan}{HTML}{218693}
      \definecolor{NTgray}{HTML}{B0B0B0}
      \definecolor{NTblackbright}{HTML}{5D5D5D}
      \definecolor{NTredbright}{HTML}{E09690}
      \definecolor{NTgreenbright}{HTML}{CDEE69}
      \definecolor{NTyellowbright}{HTML}{FFE377}
      \definecolor{NTbluebright}{HTML}{9CD9F0}
      \definecolor{NTmagentabright}{HTML}{FBB1F9}
      \definecolor{NTcyanbright}{HTML}{77DFD8}
      \definecolor{NTgraybright}{HTML}{F7F7F7}
    }
    {molokai}{
      \definecolor{NTblack}{HTML}{212121}
      \definecolor{NTred}{HTML}{fa2573}
      \definecolor{NTgreen}{HTML}{98e123}
      \definecolor{NTyellow}{HTML}{dfd460}
      \definecolor{NTblue}{HTML}{1080d0}
      \definecolor{NTmagenta}{HTML}{8700ff}
      \definecolor{NTcyan}{HTML}{43a8d0}
      \definecolor{NTgray}{HTML}{bbbbbb}
      \definecolor{NTblackbright}{HTML}{555555}
      \definecolor{NTredbright}{HTML}{f6669d}
      \definecolor{NTgreenbright}{HTML}{b1e05f}
      \definecolor{NTyellowbright}{HTML}{fff26d}
      \definecolor{NTbluebright}{HTML}{00afff}
      \definecolor{NTmagentabright}{HTML}{af87ff}
      \definecolor{NTcyanbright}{HTML}{51ceff}
      \definecolor{NTgraybright}{HTML}{ffffff}
    }
    {monokaisoda}{
      \definecolor{NTblack}{HTML}{1a1a1a}
      \definecolor{NTred}{HTML}{f4005f}
      \definecolor{NTgreen}{HTML}{98e024}
      \definecolor{NTyellow}{HTML}{fa8419}
      \definecolor{NTblue}{HTML}{9d65ff}
      \definecolor{NTmagenta}{HTML}{f4005f}
      \definecolor{NTcyan}{HTML}{58d1eb}
      \definecolor{NTgray}{HTML}{c4c5b5}
      \definecolor{NTblackbright}{HTML}{625e4c}
      \definecolor{NTredbright}{HTML}{f4005f}
      \definecolor{NTgreenbright}{HTML}{98e024}
      \definecolor{NTyellowbright}{HTML}{e0d561}
      \definecolor{NTbluebright}{HTML}{9d65ff}
      \definecolor{NTmagentabright}{HTML}{f4005f}
      \definecolor{NTcyanbright}{HTML}{58d1eb}
      \definecolor{NTgraybright}{HTML}{f6f6ef}
    }
  }
  \str_case_e:nn{\NTK@thememode}{
    {dark}{
      \definecolor{NTbackground}{named}{NTblack}
      \definecolor{NTfont}{named}{NTgraybright}
    }
    {light}{
      \definecolor{NTbackground}{named}{NTgraybright}
      \definecolor{NTfont}{named}{NTblack}
    }
  }
}
\ExplSyntaxOff
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\NT@fonts}
%    \begin{macrocode}
\def\NT@fonts{
  \bfseries%
  \NTK@fontsize%
  \setmonofont{\NTK@font}%
  \ttfamily%
  \setlength{\parindent}{0pt}%
  \setlength{\parskip}{-0.9pt}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\nodetreereset}
%    \begin{macrocode}
\def\nodetreereset{
  \nodetreeset{theme=monokaisoda,thememode=dark,font={Ubuntu Mono},fontsize=\tiny}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{nodetreeexample}
%    \begin{macrocode}
\newenvironment{nodetreeexample}[1][]{
  \setkeys{NT}{#1}
  \NT@colors
  \begin{mdframed}[
    linecolor=black,
    backgroundcolor=NTbackground,
    fontcolor=NTfont,
  ]%
  \NT@fonts
}{
  \end{mdframed}%
}
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\nodetreetermemulator}
%    \begin{macrocode}
\newcommand{\nodetreeterminalemulator}[2][]{
  \setkeys{NT}{#1}
  \begin{nodetreeexample}
  \input{#2_nodetree.tex}
  \end{nodetreeexample}
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\NewDocumentEnvironment { nodetreeShow } { +b } {
  \directlua{
    nodetree.compile_include('\luaescapestring{\unexpanded{#1}}')
  }
}{}
%    \end{macrocode}
%
% End of the documentation mode.
%    \begin{macrocode}
\fi
%    \end{macrocode}
%
% \iffalse
%</package>
%<*luamain>
% \fi
%
% \makeatletter
% \c@CodelineNo 0 \relax
% \makeatother
%
% \subsection{The file \tt{nodetree.lua}}
%
% Add some informations and references
%    \begin{macrocode}
-- This is a autogenerated file.
-- For more informations please read the manual.
-- http://mirrors.ctan.org/macros/luatex/generic/nodetree/nodetree.pdf
%    \end{macrocode}
%
%    \begin{macrocode}
if not modules then modules = { } end modules ['nodetree'] = {
  version   = '1.2',
  comment   = 'nodetree',
  author    = 'Josef Friedrich',
  copyright = 'Josef Friedrich',
  license   = 'The LaTeX Project Public License Version 1.3c 2008-05-04'
}
%    \end{macrocode}
%
%    \begin{macrocode}
local node_extended = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local template = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local tree = {}
%    \end{macrocode}
%
% Nodes in Lua\TeX{} are connected. The nodetree view distinguishs
% between the |list| and |field| connections.
%
% \begin{itemize}
%  \item |list|: Nodes, which are double connected by |next| and
%        |previous| fields.
%  \item |field|: Connections to nodes by other fields than |next| and
%        |previous| fields, e. g. |head|, |pre|.
% \end{itemize}
%
% The lua table named |tree.state| holds state values for the current
% tree item.
%
% \begin{code}
%  tree.state:
%    - 1:
%      - list: continue
%      - field: stop
%    - 2:
%      - list: continue
%      - field: stop
% \end{code}
%    \begin{macrocode}
tree.state = {}
%    \end{macrocode}
% A counter for the compiled TeX examples. Some TeX code snippets
% a written into file, wrapped with some TeX boilerplate code.
% This written files are compiled.
%    \begin{macrocode}
local example_counter = 0
%    \end{macrocode}
% Table to bundle all callback wrapper functions.
%    \begin{macrocode}
local callbacks = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local export = {}
%    \end{macrocode}
% The default options
%    \begin{macrocode}
local options = {
  verbosity = 1,
  callback = 'postlinebreak',
  engine = 'luatex',
  color = 'colored',
  decimalplaces = 2,
  unit = 'pt',
  channel = 'term',
}
%    \end{macrocode}
% File descriptor
%    \begin{macrocode}
local output_file
%    \end{macrocode}
%
% \subsubsection{node\_extended --- Extend the node library}
%
% \TmpLuaFunction{node_id}
% Get the node id form, e. g.:
% \begin{code}
% <node    nil <    172 >    nil : hlist 2>
% \end{code}
%    \begin{macrocode}
function node_extended.node_id(n)
  return string.gsub(tostring(n), '^<node%s+%S+%s+<%s+(%d+).*', '%1')
end
%    \end{macrocode}
%
% \TmpLuaFunction{subtype}
%    \begin{macrocode}
function node_extended.subtype(n)
  local typ = node.type(n.id)
  local subtypes = {
%    \end{macrocode}
% \paragraph{hlist (0)}
%    \begin{macrocode}
    hlist = {
      [0] = 'unknown',
      [1] = 'line',
      [2] = 'box',
      [3] = 'indent',
      [4] = 'alignment',
      [5] = 'cell',
      [6] = 'equation',
      [7] = 'equationnumber',
    },
%    \end{macrocode}
% \paragraph{vlist (1)}
%    \begin{macrocode}
    vlist = {
      [0] = 'unknown',
      [4] = 'alignment',
      [5] = 'cell',
    },
%    \end{macrocode}
% \paragraph{rule (2)}
%    \begin{macrocode}
    rule = {
      [0] = 'unknown',
      [1] = 'box',
      [2] = 'image',
      [3] = 'empty',
      [4] = 'user',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item ins (3)
% \item mark (4)
% \end{compactitem}
%    \begin{macrocode}
%    \end{macrocode}
% \paragraph{adjust (5)}
%    \begin{macrocode}
    adjust = {
      [0] = 'normal',
      [1] = 'pre',
    },
%    \end{macrocode}
% \paragraph{boundary (6)}
%    \begin{macrocode}
    boundary = {
      [0] = 'cancel',
      [1] = 'user',
      [2] = 'protrusion',
      [3] = 'word',
    },
%    \end{macrocode}
% \paragraph{disc (7)}
%    \begin{macrocode}
    disc  = {
      [0] = 'discretionary',
      [1] = 'explicit',
      [2] = 'automatic',
      [3] = 'regular',
      [4] = 'first',
      [5] = 'second',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item whatsit (8)
% \item local\_par (9)
% \item dir (10)
% \end{compactitem}
%
% \paragraph{math (11)}
%    \begin{macrocode}
    math = {
      [0] = 'beginmath',
      [1] = 'endmath',
    },
%    \end{macrocode}
% \paragraph{glue (12)}
%    \begin{macrocode}
    glue = {
      [0]   = 'userskip',
      [1]   = 'lineskip',
      [2]   = 'baselineskip',
      [3]   = 'parskip',
      [4]   = 'abovedisplayskip',
      [5]   = 'belowdisplayskip',
      [6]   = 'abovedisplayshortskip',
      [7]   = 'belowdisplayshortskip',
      [8]   = 'leftskip',
      [9]   = 'rightskip',
      [10]  = 'topskip',
      [11]  = 'splittopskip',
      [12]  = 'tabskip',
      [13]  = 'spaceskip',
      [14]  = 'xspaceskip',
      [15]  = 'parfillskip',
      [16]  = 'mathskip',
      [17]  = 'thinmuskip',
      [18]  = 'medmuskip',
      [19]  = 'thickmuskip',
      [98]  = 'conditionalmathskip',
      [99]  = 'muglue',
      [100] = 'leaders',
      [101] = 'cleaders',
      [102] = 'xleaders',
      [103] = 'gleaders',
    },
%    \end{macrocode}
% \paragraph{kern (13)}
%    \begin{macrocode}
    kern = {
      [0] = 'fontkern',
      [1] = 'userkern',
      [2] = 'accentkern',
      [3] = 'italiccorrection',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item penalty (14)
% \item unset (15)
% \item style (16)
% \item choice (17)
% \end{compactitem}
%
% \paragraph{noad (18)}
%    \begin{macrocode}
    noad = {
      [0] = 'ord',
      [1] = 'opdisplaylimits',
      [2] = 'oplimits',
      [3] = 'opnolimits',
      [4] = 'bin',
      [5] = 'rel',
      [6] = 'open',
      [7] = 'close',
      [8] = 'punct',
      [9] = 'inner',
      [10] = 'under',
      [11] = 'over',
      [12] = 'vcenter',
    },
%    \end{macrocode}
% \paragraph{radical (19)}
%    \begin{macrocode}
    radical = {
      [0] = 'radical',
      [1] = 'uradical',
      [2] = 'uroot',
      [3] = 'uunderdelimiter',
      [4] = 'uoverdelimiter',
      [5] = 'udelimiterunder',
      [6] = 'udelimiterover',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item fraction (20)
% \end{compactitem}
%
% \paragraph{accent (21)}
%    \begin{macrocode}
    accent = {
      [0] = 'bothflexible',
      [1] = 'fixedtop',
      [2] = 'fixedbottom',
      [3] = 'fixedboth',
    },
%    \end{macrocode}
% \paragraph{fence (22)}
%    \begin{macrocode}
    fence = {
      [0] = 'unset',
      [1] = 'left',
      [2] = 'middle',
      [3] = 'right',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item math\_char (23)
% \item sub\_box (24)
% \item sub\_mlist (25)
% \item math\_text\_char (26)
% \item delim (27)
% \item margin\_kern (28)
% \end{compactitem}
%
% \paragraph{glyph (29)}
%    \begin{macrocode}
    glyph = {
      [0] = 'character',
      [1] = 'ligature',
      [2] = 'ghost',
      [3] = 'left',
      [4] = 'right',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item align\_record (30)
% \item pseudo\_file (31)
% \item pseudo\_line (32)
% \item page\_insert (33)
% \item split\_insert (34)
% \item expr\_stack (35)
% \item nested\_list (36)
% \item span (37)
% \item attribute (38)
% \item glue\_spec (39)
% \item attribute\_list (40)
% \item temp (41)
% \item align\_stack (42)
% \item movement\_stack (43)
% \item if\_stack (44)
% \item unhyphenated (45)
% \item hyphenated (46)
% \item delta (47)
% \item passive (48)
% \item shape (49)
% \end{compactitem}
%    \begin{macrocode}
  }
  subtypes.whatsit = node.whatsits()
  local out = ''
  if subtypes[typ] and subtypes[typ][n.subtype] then
    out = subtypes[typ][n.subtype]
    if options.verbosity > 1 then
      out = out .. template.type_id(n.subtype)
    end
    return out
  else
    return tostring(n.subtype)
  end
  assert(false)
end
%    \end{macrocode}
%
% \subsubsection{template --- Template function}
%
% \TmpLuaFunction{underscore}
%    \begin{macrocode}
function template.underscore(string)
  if options.channel == 'tex' then
    return string.gsub(string, '_', '\\_')
  else
    return string
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{escape}
%    \begin{macrocode}
function template.escape(string)
  if options.channel == 'tex' then
    return string.gsub(string, [[\]], [[\string\]])
  else
    return string
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.round(number)
  local mult = 10^(options.decimalplaces or 0)
  return math.floor(number * mult + 0.5) / mult
end
%    \end{macrocode}
%
% \TmpLuaFunction{whitespace}
%    \begin{macrocode}
function template.whitespace(count)
  local whitespace, out = '', ''
  if options.channel == 'tex' then
    whitespace = '\\hspace{0.5em}'
  else
    whitespace = ' '
  end
  if not count then
    count = 1
  end
  for i = 1, count do
    out = out .. whitespace
  end
  return out
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.length(input)
  input = tonumber(input)
  input = input / tex.sp('1' .. options.unit)
  return string.format('%g%s', template.round(input), options.unit)
end
%    \end{macrocode}
%
% \TmpLuaFunction{fill}
%    \begin{macrocode}
function template.fill(number, order, field)
  if order ~= nil and order ~= 0 then
    if field == 'stretch' then
      out = '+'
    else
      out = '-'
    end
    return out .. string.format(
      '%gfi%s', number / 2^16,
      string.rep('l', order - 1)
    )
  else
    return template.length(number)
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{node_colors}
%    \begin{macrocode}
template.node_colors = {
  hlist = {'red', 'bright'},
  vlist = {'green', 'bright'},
  rule = {'blue', 'bright'},
  ins = {'blue'},
  mark = {'magenta'},
  adjust = {'cyan'},
  boundary = {'red', 'bright'},
  disc = {'green', 'bright'},
  whatsit = {'yellow', 'bright'},
  local_par = {'blue', 'bright'},
  dir = {'magenta', 'bright'},
  math = {'cyan', 'bright'},
  glue = {'magenta', 'bright'},
  kern = {'green', 'bright'},
  penalty = {'yellow', 'bright'},
  unset = {'blue'},
  style = {'magenta'},
  choice = {'cyan'},
  noad = {'red'},
  radical = {'green'},
  fraction = {'yellow'},
  accent = {'blue'},
  fence = {'magenta'},
  math_char = {'cyan'},
  sub_box = {'red', 'bright'},
  sub_mlist = {'green', 'bright'},
  math_text_char = {'yellow', 'bright'},
  delim = {'blue', 'bright'},
  margin_kern = {'magenta', 'bright'},
  glyph = {'cyan', 'bright'},
  align_record = {'red'},
  pseudo_file = {'green'},
  pseudo_line = {'yellow'},
  page_insert = {'blue'},
  split_insert = {'magenta'},
  expr_stack = {'cyan'},
  nested_list = {'red'},
  span = {'green'},
  attribute = {'yellow'},
  glue_spec = {'magenta'},
  attribute_list = {'cyan'},
  temp = {'magenta'},
  align_stack = {'red', 'bright'},
  movement_stack = {'green', 'bright'},
  if_stack = {'yellow', 'bright'},
  unhyphenated = {'magenta', 'bright'},
  hyphenated = {'cyan', 'bright'},
  delta = {'red'},
  passive = {'green'},
  shape = {'yellow'},
}
%    \end{macrocode}
%
% \TmpLuaFunction{color_code}
%    \begin{macrocode}
function template.color_code(code)
  return string.char(27) .. '[' .. tostring(code) .. 'm'
end
%    \end{macrocode}
%
% \TmpLuaFunction{color}
% \begin{code}
% local colors = {
%     -- attributes
%     reset = 0,
%     clear = 0,
%     bright = 1,
%     dim = 2,
%     underscore = 4,
%     blink = 5,
%     reverse = 7,
%     hidden = 8,
%
%     -- foreground
%     black = 30,
%     red = 31,
%     green = 32,
%     yellow = 33,
%     blue = 34,
%     magenta = 35,
%     cyan = 36,
%     white = 37,
%
%     -- background
%     onblack = 40,
%     onred = 41,
%     ongreen = 42,
%     onyellow = 43,
%     onblue = 44,
%     onmagenta = 45,
%     oncyan = 46,
%     onwhite = 47,
% }
% \end{code}
%    \begin{macrocode}
function template.color(color, mode, background)
  if options.color ~= 'colored' then
    return ''
  end
%    \end{macrocode}
%
%    \begin{macrocode}
  local out = ''
  local code = ''
%    \end{macrocode}
%
%    \begin{macrocode}
  if mode == 'bright' then
    out = template.color_code(1)
  elseif mode == 'dim' then
    out = template.color_code(2)
  end
%    \end{macrocode}
%
%    \begin{macrocode}
  if not background then
    if color == 'reset' then code = 0
    elseif color == 'red' then code = 31
    elseif color == 'green' then code = 32
    elseif color == 'yellow' then code = 33
    elseif color == 'blue' then code = 34
    elseif color == 'magenta' then code = 35
    elseif color == 'cyan' then code = 36
    else code = 37 end
  else
    if color == 'black' then code = 40
    elseif color == 'red' then code = 41
    elseif color == 'green' then code = 42
    elseif color == 'yellow' then code = 43
    elseif color == 'blue' then code = 44
    elseif color == 'magenta' then code = 45
    elseif color == 'cyan' then code = 46
    elseif color == 'white' then code = 47
    else code = 40 end
  end
  return out .. template.color_code(code)
end
%    \end{macrocode}
%
% \TmpLuaFunction{color_tex}
%    \begin{macrocode}
function template.color_tex(color, mode, background)
  if not mode then mode = '' end
  return 'NT' .. color .. mode
end
%    \end{macrocode}
%
% \TmpLuaFunction{colored_string}
%    \begin{macrocode}
function template.colored_string(string, color, mode, background)
  if options.channel == 'tex' then
    return '\\textcolor{' ..
      template.color_tex(color, mode, background) ..
      '}{' ..
      string ..
      '}'
  else
   return template.color(color, mode, background) .. string .. template.color('reset')
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{table_inline}
%    \begin{macrocode}
function template.table_inline(o)
  local tex_escape = ''
  if options.channel == 'tex' then
    tex_escape = '\\'
  end
  if type(o) == 'table' then
     local s = tex_escape .. '{ '
     for k,v in pairs(o) do
        if type(k) ~= 'number' then k = '"'..k..'"' end
        s = s .. '['..k..'] = ' .. template.table_inline(v) .. ', '
     end
     return s .. tex_escape .. '} '
  else
     return tostring(o)
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{key_value}
%    \begin{macrocode}
function template.key_value(key, value, color)
  if type(color) ~= 'string' then
    color = 'yellow'
  end
  if options.channel == 'tex' then
    key = template.underscore(key)
  end
  local out = template.colored_string(key .. ':', color)
  if value then
    out = out .. ' ' .. value .. '; '
  end
  return out
end
%    \end{macrocode}
%
% \TmpLuaFunction{char}
%    \begin{macrocode}
function template.char(input)
  input = string.format('%q', unicode.utf8.char(input))
  if options.channel == 'tex' then
    input = template.escape(input)
  end
  return input
end
%    \end{macrocode}
%
% \TmpLuaFunction{type}
%    \begin{macrocode}
function template.type(type, id)
  local out = ''
  if options.channel == 'tex' then
    out = template.underscore(type)
  else
    out = type
  end
  out = string.upper(out)
  if options.verbosity > 1 then
    out = out .. template.type_id(id)
  end
  return template.colored_string(
    out .. template.whitespace(),
    template.node_colors[type][1],
    template.node_colors[type][2]
  )
end
%    \end{macrocode}
%
% \TmpLuaFunction{callback_variable}
%    \begin{macrocode}
function template.callback_variable(variable_name, variable)
  if variable ~= nil and variable ~= '' then
    template.print(
      template.underscore(variable_name) .. ': ' ..
      tostring(variable) ..
      template.new_line()
    )
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{line}
%    \begin{macrocode}
function template.line(length)
  local out = ''
  if length == 'long' then
    out = '------------------------------------------'
  else
    out = '-----------------------'
  end
    return out .. template.new_line()
end
%    \end{macrocode}
%
% \TmpLuaFunction{node_begin}
%    \begin{macrocode}
function template.node_begin()
  if options.channel == 'tex' then
    return '\\mbox{'
  else
    return ''
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{node_end}
%    \begin{macrocode}
function template.node_end()
  if options.channel == 'tex' then
    return '}'
  else
    return ''
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{new_line_character}
%    \begin{macrocode}
function template.new_line_character()
  if options.channel == 'tex' then
    return '\\par\n'
  else
    return '\n'
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{new_line}
%    \begin{macrocode}
function template.new_line(count)
  local out = ''
  if not count then
    count = 1
  end
  for i = 1, count do
    out = out .. template.new_line_character()
  end
  return out
end
%    \end{macrocode}
%
% \TmpLuaFunction{callback}
%    \begin{macrocode}
function template.callback(callback_name, variables)
  template.print(
    template.new_line(2) ..
    'Callback: ' ..
    template.colored_string(template.underscore(callback_name), 'red', '', true) ..
    template.new_line()
  )
  if variables then
    for name, value in pairs(variables) do
      if value ~= nil and value ~= '' then
        template.print(
          '- ' ..
          template.underscore(name) ..
          ': ' ..
          tostring(value) ..
          template.new_line()
        )
      end
    end
  end
  template.print(template.line('long'))
end
%    \end{macrocode}
%
% \TmpLuaFunction{type_id}
%    \begin{macrocode}
function template.type_id(id)
  return '[' .. tostring(id) .. ']'
end
%    \end{macrocode}
%
% \TmpLuaFunction{branch}
%    \begin{macrocode}
function template.branch(connection_type, connection_state, last)
  local c = connection_type
  local s = connection_state
  local l = last
  if c == 'list' and s == 'stop' and l == false then
    return template.whitespace(2)
  elseif c == 'field' and s == 'stop' and l == false then
    return template.whitespace(2)
  elseif c == 'list' and s == 'continue' and l == false then
    return '│' .. template.whitespace()
  elseif c == 'field' and s == 'continue' and l == false then
    return '║' .. template.whitespace()
  elseif c == 'list' and s == 'continue' and l == true then
    return '├─'
  elseif c == 'field' and s == 'continue' and l == true then
    return '╠═'
  elseif c == 'list' and s == 'stop' and l == true then
    return '└─'
  elseif c == 'field' and s == 'stop' and l == true then
    return '╚═'
  end
  return ''
end
%    \end{macrocode}
%
% \TmpLuaFunction{branches}
%    \begin{macrocode}
function template.branches(level, connection_type)
  local out = ''
  for i = 1, level - 1  do
    out = out .. template.branch('list', tree.state[i]['list'], false)
    out = out .. template.branch('field', tree.state[i]['field'], false)
  end
%    \end{macrocode}
% Format the last branches
%    \begin{macrocode}
  if connection_type == 'list' then
    out = out .. template.branch('list', tree.state[level]['list'], true)
  else
    out = out .. template.branch('list', tree.state[level]['list'], false)
    out = out .. template.branch('field', tree.state[level]['field'], true)
  end
  return out
end
%    \end{macrocode}
%
% \TmpLuaFunction{print}
%    \begin{macrocode}
function template.print(text)
  if options.channel == 'log' or options.channel == 'tex' then
    output_file:write(text)
  else
    io.write(text)
  end
end
%    \end{macrocode}
%
% \subsubsection{tree --- Build the node tree}
%
% \TmpLuaFunction{format_field}
%    \begin{macrocode}
function tree.format_field(head, field)
  local out = ''
%    \end{macrocode}
% Character "0" should be printed in a tree, because in TeX fonts the
% 0 slot usually has a symbol.
%    \begin{macrocode}
  if not head[field] or (head[field] == 0 and field ~= "char") then
    return ''
  end
%    \end{macrocode}
%
%    \begin{macrocode}
  if options.verbosity < 2 and
    -- glyph
    field == 'font' or
    field == 'left' or
    field == 'right' or
    field == 'uchyph' or
    -- hlist
    field == 'dir' or
    field == 'glue_order' or
    field == 'glue_sign' or
    field == 'glue_set' or
    -- glue
    field == 'stretch_order' then
    return ''
  elseif options.verbosity < 3 and
    field == 'prev' or
    field == 'next' or
    field == 'id'
  then
    return ''
  end
%    \end{macrocode}
%
%    \begin{macrocode}
  if field == 'prev' or field == 'next' then
    out = node_extended.node_id(head[field])
  elseif field == 'subtype' then
    out = template.underscore(node_extended.subtype(head))
  elseif
    field == 'width' or
    field == 'height' or
    field == 'depth' or
    field == 'kern' or
    field == 'shift' then
    out = template.length(head[field])
  elseif field == 'char' then
    out = template.char(head[field])
  elseif field == 'glue_set' then
    out = template.round(head[field])
  elseif field == 'stretch' or field == 'shrink' then
    out = template.fill(head[field], head[field .. '_order'], field)
  else
    out = tostring(head[field])
  end
%    \end{macrocode}
%
%    \begin{macrocode}
  return template.key_value(field, out)
end
%    \end{macrocode}
%
% \TmpLuaFunction{format_attributes}
% Attributes are key/value number pairs. They are printed as an inline
% list. The attribute |0| with the value |0| is skipped because this
% attribute is in every node by default.
%    \begin{macrocode}
function tree.format_attributes(head)
  if not head then
    return ''
  end
  local out = ''
  local attr = head.next
  while attr do
    if attr.number ~= 0 or (attr.number == 0 and attr.value ~= 0) then
      out = out .. tostring(attr.number) .. '=' .. tostring(attr.value) .. ' '
    end
    attr = attr.next
  end
  return out
end
%    \end{macrocode}
%
% \TmpLuaFunction{format_attributes}
% |level| is a integer beginning with 1. The variable |connection_type|
% is a string, which can be either |list| or |field|. The variable
% |connection_state| is a string, which can be either |continue| or
% |stop|.
%    \begin{macrocode}
function tree.set_state(level, connection_type, connection_state)
  if not tree.state[level] then
    tree.state[level] = {}
  end
  tree.state[level][connection_type] = connection_state
end
%    \end{macrocode}
%
% \TmpLuaFunction{analyze_fields}
%    \begin{macrocode}
function tree.analyze_fields(fields, level)
  local max = 0
  local connection_state = ''
  for _ in pairs(fields) do
    max = max + 1
  end
  local count = 0
  for field_name, recursion_node in pairs(fields) do
    count = count + 1
    if count == max then
      connection_state = 'stop'
    else
      connection_state = 'continue'
    end
    tree.set_state(level, 'field', connection_state)
    template.print(
      template.node_begin() ..
      template.branches(level, 'field') ..
      template.key_value(field_name) ..
      template.node_end() ..
      template.new_line()
    )
    tree.analyze_list(recursion_node, level + 1)
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{analyze_node}
%    \begin{macrocode}
function tree.analyze_node(head, level)
  local connection_state
  local out = ''
  if head.next then
    connection_state = 'continue'
  else
    connection_state = 'stop'
  end
  tree.set_state(level, 'list', connection_state)
  out = template.branches(level, 'list')
    .. template.type(node.type(head.id), head.id)
  if options.verbosity > 1 then
    out = out .. template.key_value('no', node_extended.node_id(head))
  end
%    \end{macrocode}
% We store the attributes output to append it to the field list.
%    \begin{macrocode}
  local attributes
%    \end{macrocode}
% We store fields which are nodes for later treatment.
%    \begin{macrocode}
  local fields = {}
  for field_id, field_name in pairs(node.fields(head.id, head.subtype)) do
    if field_name == 'attr' then
      attributes = tree.format_attributes(head.attr)
    elseif field_name ~= 'next' and      field_name ~= 'prev' and
      node.is_node(head[field_name]) then
      fields[field_name] = head[field_name]
    else
      out = out .. tree.format_field(head, field_name)
    end
  end
%    \end{macrocode}
% Append the attributes output if available
%    \begin{macrocode}
  if attributes ~= '' then
    out = out .. template.key_value('attr', attributes, 'blue')
  end
%    \end{macrocode}
%
%    \begin{macrocode}
  template.print(
    template.node_begin() ..
    out ..
    template.node_end() ..
    template.new_line()
  )
%    \end{macrocode}
%
%    \begin{macrocode}
  local property = node.getproperty(head)
  if property then
    template.print(
      template.node_begin() ..
      template.branches(level, 'field') ..
      '  ' ..
      template.colored_string('properties:', 'blue') .. ' ' ..
      template.table_inline(property) ..
      template.node_end() ..
      template.new_line()
    )
  end
%    \end{macrocode}
%
%    \begin{macrocode}
  tree.analyze_fields(fields, level)
end
%    \end{macrocode}
%
% \TmpLuaFunction{analyze_list}
%    \begin{macrocode}
function tree.analyze_list(head, level)
  while head do
    tree.analyze_node(head, level)
    head = head.next
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{analyze_callback}
%    \begin{macrocode}
function tree.analyze_callback(head)
  tree.analyze_list(head, 1)
  template.print(template.line('short') .. template.new_line())
end
%    \end{macrocode}
%
% \subsubsection{callbacks --- Callback wrapper}
%
% \TmpLuaFunction{contribute_filter}
%    \begin{macrocode}
function callbacks.contribute_filter(extrainfo)
  template.callback('contribute_filter', {extrainfo = extrainfo})
  return true
end
%    \end{macrocode}
%
% \TmpLuaFunction{buildpage_filter}
%    \begin{macrocode}
function callbacks.buildpage_filter(extrainfo)
  template.callback('buildpage_filter', {extrainfo = extrainfo})
  return true
end
%    \end{macrocode}
%
% \TmpLuaFunction{pre_linebreak_filter}
%    \begin{macrocode}
function callbacks.pre_linebreak_filter(head, groupcode)
  template.callback('pre_linebreak_filter', {groupcode = groupcode})
  tree.analyze_callback(head)
  return true
end
%    \end{macrocode}
%
% \TmpLuaFunction{linebreak_filter}
%    \begin{macrocode}
function callbacks.linebreak_filter(head, is_display)
  template.callback('linebreak_filter', {is_display = is_display})
  tree.analyze_callback(head)
  return true
end
%    \end{macrocode}
%
% \TmpLuaFunction{append_to_vlist_filter}
% TODO: Fix return values, page output
%    \begin{macrocode}
function callbacks.append_to_vlist_filter(head, locationcode, prevdepth, mirrored)
  local variables = {
    locationcode = locationcode,
    prevdepth = prevdepth,
    mirrored = mirrored,
  }
  template.callback('append_to_vlist_filter', variables)
  tree.analyze_callback(head)
  return true
end
%    \end{macrocode}
%
% \TmpLuaFunction{post_linebreak_filter}
%    \begin{macrocode}
function callbacks.post_linebreak_filter(head, groupcode)
  template.callback('post_linebreak_filter', {groupcode = groupcode})
  tree.analyze_callback(head)
  return true
end
%    \end{macrocode}
%
% \TmpLuaFunction{hpack_filter}
%    \begin{macrocode}
function callbacks.hpack_filter(head, groupcode, size, packtype, direction, attributelist)
  local variables = {
    groupcode = groupcode,
    size = size,
    packtype = packtype,
    direction = direction,
    attributelist = attributelist,
  }
  template.callback('hpack_filter', variables)
  tree.analyze_callback(head)
  return true
end
%    \end{macrocode}
%
% \TmpLuaFunction{vpack_filter}
%    \begin{macrocode}
function callbacks.vpack_filter(head, groupcode, size, packtype, maxdepth, direction, attributelist)
  local variables = {
    groupcode = groupcode,
    size = size,
    packtype = packtype,
    maxdepth = template.length(maxdepth),
    direction = direction,
    attributelist = attributelist,
  }
  template.callback('vpack_filter', variables)
  tree.analyze_callback(head)
  return true
end
%    \end{macrocode}
%
% \TmpLuaFunction{hpack_quality}
%    \begin{macrocode}
function callbacks.hpack_quality(incident, detail, head, first, last)
  local variables = {
    incident = incident,
    detail = detail,
    first = first,
    last = last,
  }
  template.callback('hpack_quality', variables)
  tree.analyze_callback(head)
end
%    \end{macrocode}
%
% \TmpLuaFunction{vpack_quality}
%    \begin{macrocode}
function callbacks.vpack_quality(incident, detail, head, first, last)
  local variables = {
    incident = incident,
    detail = detail,
    first = first,
    last = last,
  }
  template.callback('vpack_quality', variables)
  tree.analyze_callback(head)
end
%    \end{macrocode}
%
% \TmpLuaFunction{process_rule}
%    \begin{macrocode}
function callbacks.process_rule(head, width, height)
  local variables = {
    width = width,
    height = height,
  }
  template.callback('process_rule', variables)
  tree.analyze_callback(head)
  return true
end
%    \end{macrocode}
%
% \TmpLuaFunction{pre_output_filter}
%    \begin{macrocode}
function callbacks.pre_output_filter(head, groupcode, size, packtype, maxdepth, direction)
  local variables = {
    groupcode = groupcode,
    size = size,
    packtype = packtype,
    maxdepth = maxdepth,
    direction = direction,
  }
  template.callback('pre_output_filter', variables)
  tree.analyze_callback(head)
  return true
end
%    \end{macrocode}
%
% \TmpLuaFunction{hyphenate}
%    \begin{macrocode}
function callbacks.hyphenate(head, tail)
  template.callback('hyphenate')
  template.print('head:')
  tree.analyze_callback(head)
  template.print('tail:')
  tree.analyze_callback(tail)
end
%    \end{macrocode}
%
% \TmpLuaFunction{}
%    \begin{macrocode}
function callbacks.ligaturing(head, tail)
  template.callback('ligaturing')
  template.print('head:')
  tree.analyze_callback(head)
  template.print('tail:')
  tree.analyze_callback(tail)
end
%    \end{macrocode}
%
% \TmpLuaFunction{kerning}
%    \begin{macrocode}
function callbacks.kerning(head, tail)
  template.callback('kerning')
  template.print('head:')
  tree.analyze_callback(head)
  template.print('tail:')
  tree.analyze_callback(tail)
end
%    \end{macrocode}
%
% \TmpLuaFunction{insert_local_par}
%    \begin{macrocode}
function callbacks.insert_local_par(local_par, location)
  template.callback('insert_local_par', {location = location})
  tree.analyze_callback(local_par)
  return true
end
%    \end{macrocode}
%
% \TmpLuaFunction{mlist_to_hlist}
%    \begin{macrocode}
function callbacks.mlist_to_hlist(head, display_type, need_penalties)
  local variables = {
    display_type = display_type,
    need_penalties = need_penalties,
  }
  template.callback('mlist_to_hlist', variables)
  tree.analyze_callback(head)
  return node.mlist_to_hlist(head, display_type, need_penalties)
end
%    \end{macrocode}
%
% \subsubsection{export --- Exported functions}
%
% \TmpLuaFunction{set_option} Set a single option.
%    \begin{macrocode}
function export.set_option(key, value)
  if not options then
    options = {}
  end
  if key == 'verbosity' or key == 'decimalplaces' then
    options[key] = tonumber(value)
  else
    options[key] = value
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{set_options} Set multiple options by specifing
% a table.
%    \begin{macrocode}
function export.set_options(opts)
  if not options then
    options = {}
  end
  for key, value in pairs(opts) do
    export.set_option(key, value)
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{get_option} Get one option by specifing the key.
%    \begin{macrocode}
function export.get_option(key)
  if not options then
    options = {}
  end
  if options[key] then
    return options[key]
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{get_callback_name}
%    \begin{macrocode}
function export.get_callback_name(alias)
  if alias == 'contribute' or alias == 'contributefilter' then
    return 'contribute_filter'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'buildpage' or alias == 'buildpagefilter' then
    return 'buildpage_filter'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'preline' or alias == 'prelinebreakfilter' then
    return 'pre_linebreak_filter'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'line' or alias == 'linebreakfilter' then
    return 'linebreak_filter'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'append' or alias == 'appendtovlistfilter' then
    return 'append_to_vlist_filter'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'postline' or alias == 'postlinebreakfilter' then
    return 'post_linebreak_filter'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'hpack' or alias == 'hpackfilter' then
    return 'hpack_filter'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'vpack' or alias == 'vpackfilter' then
    return 'vpack_filter'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'hpackq' or alias == 'hpackquality' then
    return 'hpack_quality'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'vpackq' or alias == 'vpackquality' then
    return 'vpack_quality'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'process' or alias == 'processrule' then
    return 'process_rule'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'preout' or alias == 'preoutputfilter' then
    return 'pre_output_filter'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'hyph' or alias == 'hyphenate' then
    return 'hyphenate'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'liga' or alias == 'ligaturing' then
    return 'ligaturing'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'kern' or alias == 'kerning' then
   return 'kerning'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'insert' or alias == 'insertlocalpar' then
    return 'insert_local_par'
%    \end{macrocode}
%
%    \begin{macrocode}
  elseif alias == 'mhlist' or alias == 'mlisttohlist' then
    return 'mlist_to_hlist'
%    \end{macrocode}
%
%    \begin{macrocode}
  else
    return 'post_linebreak_filter'
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{register}
%    \begin{macrocode}
function export.register(cb)
  if options.engine == 'lualatex' then
    luatexbase.add_to_callback(cb, callbacks[cb], 'nodetree')
  else
    id, error = callback.register(cb, callbacks[cb])
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{register_callbacks}
%    \begin{macrocode}
function export.register_callbacks()
  if options.channel == 'log' or options.channel == 'tex' then
    output_file = io.open(tex.jobname .. '_nodetree.' .. options.channel, 'a')
  end
  for alias in string.gmatch(options.callback, '([^,]+)') do
    export.register(export.get_callback_name(alias))
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{unregister}
%    \begin{macrocode}
function export.unregister(cb)
  if options.engine == 'lualatex' then
    luatexbase.remove_from_callback(cb, 'nodetree')
  else
    id, error = callback.register(cb, nil)
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{unregister_callbacks}
%    \begin{macrocode}
function export.unregister_callbacks()
  for alias in string.gmatch(options.callback, '([^,]+)') do
    export.unregister(export.get_callback_name(alias))
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{execute}
%    \begin{macrocode}
function export.execute()
  local c = export.get_callback()
  if options.engine == 'lualatex' then
    luatexbase.add_to_callback(c, callbacks.post_linebreak_filter, 'nodetree')
  else
    id, error = callback.register(c, callbacks.post_linebreak_filter)
  end
end
%    \end{macrocode}
%
% \TmpLuaFunction{compile_include}
%    \begin{macrocode}
function export.compile_include(tex_markup)
  example_counter = example_counter + 1
  local filename_tex = tex.jobname .. '_' .. example_counter .. '_nodetree.tex'
  output_file = io.open(filename_tex, 'w')
  local prefix = '%!TEX program = lualatex\n' ..
                 '\\documentclass{article}\n' ..
                 '\\usepackage[channel=tex]{nodetree}\n' ..
                 '\\begin{document}\n'
  local suffix = '\n\\end{document}'
  output_file:write(prefix .. tex_markup .. suffix)
  output_file:close()
  local status, error = os.spawn({ 'lualatex', filename_tex })
  print(status)
  print(error)
end
%    \end{macrocode}
%
% \TmpLuaFunction{analyze}
%    \begin{macrocode}
function export.analyze(head)
  template.print(template.new_line())
  tree.analyze_list(head, 1)
end
%    \end{macrocode}
%
% \TmpLuaFunction{print}
%    \begin{macrocode}
function export.print(head, opts)
  if opts and type(opts) == 'table' then
    export.set_options(opts)
  end
  template.print(template.new_line())
  tree.analyze_list(head, 1)
end
%    \end{macrocode}
%
%    \begin{macrocode}
return export
%    \end{macrocode}
% \iffalse
%</luamain>
% \fi
%
% \Finale
\endinput
