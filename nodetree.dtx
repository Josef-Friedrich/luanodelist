% \iffalse meta-comment
%
% Copyright (C) 2015 by Josef Friedrich <josef@friedrich.rocks>
% ----------------------------------------------------------------------
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, either version 1.3 of this license
% or (at your option) any later version.  The latest version of this
% license is in:
%
%   http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Josef Friedrich.
%
% This work consists of the files nodetree.dtx and nodetree.ins
% and the derived filebase nodetree.sty and nodetree.lua.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{nodetree.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{nodetree}
%<*package>
    [2015/11/13 Package to debug node lists used by LuaTeX]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage{hyperref,paralist}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}

\providecommand*{\url}{\texttt}
\GetFileInfo{nodetree.dtx}
\title{The \textsf{nodetree} package}
\author{%
  Josef Friedrich\\%
  \url{josef@friedrich.rocks}\\%
  \href{https://github.com/Josef-Friedrich/cloze}{github.com/Josef-Friedrich/nodetree}%
}
\date{\fileversion~from \filedate}

\maketitle

\tableofcontents

  \DocInput{nodetree.dtx}
  \pagebreak
  \PrintChanges
  \pagebreak
  \PrintIndex
\end{document}
%</driver>
%<*readme>
# nodetree

Inspired by a [gist of Patrick Gundlach](https://gist.github.com/pgundlach/556247).

`nodetree` displays some debug informations of the node list in the
terminal, when you render a Latex document.

```
post_linebreak_filter:
│
├─GLUE subtype: baselineskip; width: 5.06pt;
└─HLIST subtype: line; width: 345pt; height: 6.94pt; dir: TLT; glue_order: 2; glue_sign: 1; glue_set: 304.99993896484;
 ╚═head:
  ├─LOCAL_PAR dir: TLT;
  ├─HLIST subtype: indent; width: 15pt; dir: TLT;
  ├─GLYPH char: "O"; font: 15; left: 2; right: 3; uchyph: 1; width: 7.78pt; height: 6.83pt;
  ├─DISC subtype: regular; penalty: 50;
  │ ╠═post:
  │ ║ └─GLYPH subtype: ghost; char: "\12"; font: 15; width: 5.56pt; height: 6.94pt;
  │ ║  ╚═components:
  │ ║   ├─GLYPH subtype: ligature; char: "f"; font: 15; left: 2; right: 3; uchyph: 1; width: 3.06pt; height: 6.94pt;
  │ ║   └─GLYPH subtype: ligature; char: "i"; font: 15; left: 2; right: 3; uchyph: 1; width: 2.78pt; height: 6.68pt;
  │ ╠═pre:
  │ ║ ├─GLYPH char: "f"; font: 15; left: 2; right: 3; uchyph: 1; width: 3.06pt; height: 6.94pt;
  │ ║ └─GLYPH char: "-"; font: 15; left: 2; right: 3; uchyph: 1; width: 3.33pt; height: 4.31pt;
  │ ╚═replace:
  │  └─GLYPH subtype: ghost; char: "\14"; font: 15; width: 8.33pt; height: 6.94pt;
  │   ╚═components:
  │    ├─GLYPH subtype: ghost; char: "\11"; font: 15; width: 5.83pt; height: 6.94pt;
  │    │ ╚═components:
  │    │  ├─GLYPH subtype: ligature; char: "f"; font: 15; left: 2; right: 3; uchyph: 1; width: 3.06pt; height: 6.94pt;
  │    │  └─GLYPH subtype: ligature; char: "f"; font: 15; left: 2; right: 3; uchyph: 1; width: 3.06pt; height: 6.94pt;
  │    └─GLYPH subtype: ligature; char: "i"; font: 15; left: 2; right: 3; uchyph: 1; width: 2.78pt; height: 6.68pt;
  ├─GLYPH char: "c"; font: 15; left: 2; right: 3; uchyph: 1; width: 4.44pt; height: 4.31pt;
  ├─GLYPH char: "e"; font: 15; left: 2; right: 3; uchyph: 1; width: 4.44pt; height: 4.31pt;
  ├─PENALTY penalty: 10000;
  ├─GLUE subtype: parfillskip; stretch: 65536; stretch_order: 2;
  └─GLUE subtype: rightskip;

```

# UTF8 Box drawing symbols

## Light

```
│ │
│ ├─┤field1: 1pt├┤field2: 1pt│
│ └─
└─
```

## Heavy

```
┃ ┃
┃ ┣━┫field1: 1pt┣┫field2: 1pt┃
┃ ┗━
┗━
```

## Double

```
║ ║
║ ╠═╣field1: 1pt╠╣field2: 1pt║
║ ╚═
╚═
```

%</readme>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.1}{2015/06/16}{Converted to DTX file}
% \changes{v1.0}{2015/07/08}{Inital release}
%
% \DoNotIndex{\newcommand,\newenvironment,\def,\directlua}
%
% \StopEventually{}
% \pagebreak
% \section{Implementation}
%
% \iffalse
%<*tex>
% \fi
% \MacroTopsep = 10pt plus 2pt minus 2pt
% \MacrocodeTopsep = 10pt plus 1.2pt minus 1pt
% \makeatletter
% \c@CodelineNo 25 \relax
% \makeatother
%
% \subsection{The file \tt{nodetree.tex}}
%
%    \begin{macrocode}
\directlua{
  nodetree = require('nodetree')
}
\def\nodetreeoption[#1]#2{
  \directlua{
    nodetree.set_option('#1', '#2')
  }
}
\def\nodetreeshowoption#1{
  \directlua{
    tex.print(nodetree.get_option('#1'))
  }
}
\def\nodetreeprocessoptions{
  \nodetreeoption[engine]{luatex}
  \directlua{
    nodetree.set_default_options()
    nodetree.register_callbacks()
  }
}
%    \end{macrocode}
%
% \iffalse
%</tex>
%<*package>
% \fi
% \makeatletter
% \c@CodelineNo 25 \relax
% \makeatother
%
% \subsection{The file \tt{nodetree.sty}}
%
%    \begin{macrocode}
\directlua{
  nodetree = require('nodetree')
  nodetree.set_option('engine', 'lualatex')
}
%    \end{macrocode}
%    \begin{macrocode}
\RequirePackage{kvoptions}
%    \end{macrocode}
%
%    \begin{macrocode}
\SetupKeyvalOptions{
  family=NT,
  prefix=NT@
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\NT@set@option[#1]#2{%
  \directlua{nodetree.set_option('#1', '#2')}%
}
\DeclareStringOption[colored]{color}
\define@key{NT}{color}[]{\NT@set@option[color]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[postlinebreak]{callback}
\define@key{NT}{callback}[]{\NT@set@option[callback]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareStringOption[1]{verbosity}
\define@key{NT}{verbosity}[]{\NT@set@option[verbosity]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\ProcessKeyvalOptions*
\directlua{
  nodetree.set_default_options()
  nodetree.register_callbacks()
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand{\nodetreeset}[1]{\setkeys{nodetree}{#1}}
%    \end{macrocode}
%
% \iffalse
%</package>
%<*luamain>
% \fi
%
% \makeatletter
% \c@CodelineNo 0 \relax
% \makeatother
%
% \subsection{The file \tt{nodetree.lua}}
%
%
%    \begin{macrocode}
local nodex = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local template = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local nodetree = {}
%    \end{macrocode}
%
% Nodes in Lua\TeX are connected. The nodetree view distinguishs betweens
% the |list| and |field| connections.

% \begin{itemize}
%  \item |list|: Nodes, which are double connected by |next| and
%        |previous| fields.
%  \item |field|: Connections to nodes by other fields than |next| and
%        |previous| fields, e. g. |head|, |pre|.
% \end{itemize}
%
% The lua table named |nodetree| holds states values for the present nodetree
% item.
% \begin{verbatim}
%  nodetree:
%    - 1:
%      - list: continue
%      - field: stop
%    - 2:
%      - list: continue
%      - field: stop
% \end{verbatim}
%    \begin{macrocode}
nodetree.state = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local base = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local options = {}
%    \end{macrocode}
%
% \subsubsection{nodex --- node extended}
%
% Get the node id form, e. g.:
% \begin{verbatim}
% <node    nil <    172 >    nil : hlist 2>
% \end{verbatim}
%    \begin{macrocode}
function nodex.node_id(n)
  return string.gsub(tostring(n), '^<node%s+%S+%s+<%s+(%d+).*', '%1')
end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodex.subtype(n)
  local typ = node.type(n.id)

  local subtypes = {
%    \end{macrocode}
% \paragraph{hlist (0)}
%    \begin{macrocode}
    hlist = {
      [0] = 'unknown',
      [1] = 'line',
      [2] = 'box',
      [3] = 'indent',
      [4] = 'alignment',
      [5] = 'cell',
      [6] = 'equation',
      [7] = 'equationnumber',
    },
%    \end{macrocode}
% \paragraph{vlist (1)}
%    \begin{macrocode}
    vlist = {
      [0] = 'unknown',
      [4] = 'alignment',
      [5] = 'cell',
    },
%    \end{macrocode}
% \paragraph{rule (2)}
%    \begin{macrocode}
    rule = {
      [0] = 'unknown',
      [1] = 'box',
      [2] = 'image',
      [3] = 'empty',
      [4] = 'user',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item ins (3)
% \item mark (4)
% \end{compactitem}
%    \begin{macrocode}
%    \end{macrocode}
% \paragraph{adjust (5)}
%    \begin{macrocode}
    adjust = {
      [0] = 'normal',
      [1] = 'pre',
    },
%    \end{macrocode}
% \paragraph{boundary (6)}
%    \begin{macrocode}
    boundary = {
      [0] = 'cancel',
      [1] = 'user',
      [2] = 'protrusion',
      [3] = 'word',
    },
%    \end{macrocode}
% \paragraph{disc (7)}
%    \begin{macrocode}
    disc  = {
      [0] = 'discretionary',
      [1] = 'explicit',
      [2] = 'automatic',
      [3] = 'regular',
      [4] = 'first',
      [5] = 'second',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item whatsit (8)
% \item local\_par (9)
% \item dir (10)
% \end{compactitem}
%
% \paragraph{math (11)}
%    \begin{macrocode}
    math = {
      [0] = 'beginmath',
      [1] = 'endmath',
    },
%    \end{macrocode}
% \paragraph{glue (12)}
%    \begin{macrocode}
    glue = {
      [0]   = 'userskip',
      [1]   = 'lineskip',
      [2]   = 'baselineskip',
      [3]   = 'parskip',
      [4]   = 'abovedisplayskip',
      [5]   = 'belowdisplayskip',
      [6]   = 'abovedisplayshortskip',
      [7]   = 'belowdisplayshortskip',
      [8]   = 'leftskip',
      [9]   = 'rightskip',
      [10]  = 'topskip',
      [11]  = 'splittopskip',
      [12]  = 'tabskip',
      [13]  = 'spaceskip',
      [14]  = 'xspaceskip',
      [15]  = 'parfillskip',
      [16]  = 'mathskip',
      [17]  = 'thinmuskip',
      [18]  = 'medmuskip',
      [19]  = 'thickmuskip',
      [98]  = 'conditionalmathskip',
      [99]  = 'muglue',
      [100] = 'leaders',
      [101] = 'cleaders',
      [102] = 'xleaders',
      [103] = 'gleaders',
    },
%    \end{macrocode}
% \paragraph{kern (13)}
%    \begin{macrocode}
    kern = {
      [0] = 'fontkern',
      [1] = 'userkern',
      [2] = 'accentkern',
      [3] = 'italiccorrection',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item penalty (14)
% \item unset (15)
% \item style (16)
% \item choice (17)
% \end{compactitem}
%
% \paragraph{noad (18)}
%    \begin{macrocode}
    noad = {
      [0] = 'ord',
      [1] = 'opdisplaylimits',
      [2] = 'oplimits',
      [3] = 'opnolimits',
      [4] = 'bin',
      [5] = 'rel',
      [6] = 'open',
      [7] = 'close',
      [8] = 'punct',
      [9] = 'inner',
      [10] = 'under',
      [11] = 'over',
      [12] = 'vcenter',
    },
%    \end{macrocode}
% \paragraph{radical (19)}
%    \begin{macrocode}
    radical = {
      [0] = 'radical',
      [1] = 'uradical',
      [2] = 'uroot',
      [3] = 'uunderdelimiter',
      [4] = 'uoverdelimiter',
      [5] = 'udelimiterunder',
      [6] = 'udelimiterover',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item fraction (20)
% \end{compactitem}
%
% \paragraph{accent (21)}
%    \begin{macrocode}
    accent = {
      [0] = 'bothflexible',
      [1] = 'fixedtop',
      [2] = 'fixedbottom',
      [3] = 'fixedboth',
    },
%    \end{macrocode}
% \paragraph{fence (22)}
%    \begin{macrocode}
    fence = {
      [0] = 'unset',
      [1] = 'left',
      [2] = 'middle',
      [3] = 'right',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item math\_char (23)
% \item sub\_box (24)
% \item sub\_mlist (25)
% \item math\_text\_char (26)
% \item delim (27)
% \item margin\_kern (28)
% \end{compactitem}
%
% \paragraph{glyph (29)}
%    \begin{macrocode}
    glyph = {
      [0] = 'character',
      [1] = 'ligature',
      [2] = 'ghost',
      [3] = 'left',
      [4] = 'right',
    },
%    \end{macrocode}
%
% \noindent
% Nodes without subtypes:
% \begin{compactitem}
% \item align\_record (30)
% \item pseudo\_file (31)
% \item pseudo\_line (32)
% \item page\_insert (33)
% \item split\_insert (34)
% \item expr\_stack (35)
% \item nested\_list (36)
% \item span (37)
% \item attribute (38)
% \item glue\_spec (39)
% \item attribute\_list (40)
% \item temp (41)
% \item align\_stack (42)
% \item movement\_stack (43)
% \item if\_stack (44)
% \item unhyphenated (45)
% \item hyphenated (46)
% \item delta (47)
% \item passive (48)
% \item shape (49)
% \end{compactitem}
%    \begin{macrocode}
  }

  subtypes.whatsit = node.whatsits()

  local out = ''
  if subtypes[typ] and subtypes[typ][n.subtype] then
    out = subtypes[typ][n.subtype]

    if options.verbosity > 1 then
      out = out .. template.type_id(n.subtype)
    end

    return out
  else
    return tostring(n.subtype)
  end

  assert(false)
end
%    \end{macrocode}
%
% \subsubsection{template}
%
%    \begin{macrocode}
function template.color_code(code)
  return string.char(27) .. '[' .. tostring(code) .. 'm'
end
%    \end{macrocode}
%
% \begin{verbatim}
% local colors = {
%     -- attributes
%     reset = 0,
%     clear = 0,
%     bright = 1,
%     dim = 2,
%     underscore = 4,
%     blink = 5,
%     reverse = 7,
%     hidden = 8,
%
%     -- foreground
%     black = 30,
%     red = 31,
%     green = 32,
%     yellow = 33,
%     blue = 34,
%     magenta = 35,
%     cyan = 36,
%     white = 37,
%
%     -- background
%     onblack = 40,
%     onred = 41,
%     ongreen = 42,
%     onyellow = 43,
%     onblue = 44,
%     onmagenta = 45,
%     oncyan = 46,
%     onwhite = 47,
% }
% \end{verbatim}
%    \begin{macrocode}
function template.color(color, mode, background)
  if options.color ~= 'colored' then
    return ''
  end

  local out = ''
  local code = ''

  if mode == 'bright' then
    out = template.color_code(1)
  elseif mode == 'dim' then
    out = template.color_code(2)
  end

  if not background then
    if color == 'reset' then code = 0
    elseif color == 'red' then code = 31
    elseif color == 'green' then code = 32
    elseif color == 'yellow' then code = 33
    elseif color == 'blue' then code = 34
    elseif color == 'magenta' then code = 35
    elseif color == 'cyan' then code = 36
    else code = 37 end
  else
    if color == 'black' then code = 40
    elseif color == 'red' then code = 41
    elseif color == 'green' then code = 42
    elseif color == 'yellow' then code = 43
    elseif color == 'blue' then code = 44
    elseif color == 'magenta' then code = 45
    elseif color == 'cyan' then code = 46
    elseif color == 'white' then code = 47
    else code = 40 end
  end

  return out .. template.color_code(code)

end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.key_value(key, value)
  local out = template.color('yellow') .. key .. ': '
  if value then
    out = out .. template.color('white') .. value .. '; '
  end
  return out .. template.color('reset')
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.length(input)
  input = tonumber(input)
  input = input / 2^16
  input = math.floor((input * 10^2) + 0.5) / (10^2)
  return string.format('%gpt', input)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.char(input)
  return string.format('%q', unicode.utf8.char(input))
end
%    \end{macrocode}
%
% t = type
%    \begin{macrocode}
function template.type(t, id)
  local out = ''
  out = template.type_color(t) .. string.upper(t)

  if options.verbosity > 1 then
    out = out .. template.type_id(id)
  end

  return out .. template.color('reset')  .. ' '
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.callback_variable(variable_name, variable)
  if variable ~= nil and variable ~= '' then
    template.print(variable_name .. ': ' .. tostring(variable))
  end
end
%    \end{macrocode}
%    \begin{macrocode}
function template.callback(callback_name, variables)
  template.print('\n\n')
  template.print('Callback: ' .. template.color('red', '', true) ..
    callback_name .. template.color('reset')
  )
  if variables then
    for name, value in pairs(variables) do
      if value ~= nil and value ~= '' then
        template.print('  - ' .. name .. ': ' .. tostring(value))
      end
    end
  end
  template.print('-----------------------')
end
%    \end{macrocode}
%    \begin{macrocode}
function template.type_id(id)
  return '[' .. tostring(id) .. ']'
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.branch(connection_type, connection_state, last)
  local c = connection_type
  local s = connection_state
  local l = last
  if c == 'list' and s == 'stop' and l == false then
    return ' '
  elseif c == 'field' and s == 'stop' and l == false then
    return ' '
  elseif c == 'list' and s == 'continue' and l == false then
    return '│ '
  elseif c == 'field' and s == 'continue' and l == false then
    return '║ '
  elseif c == 'list' and s == 'continue' and l == true then
    return '├─'
  elseif c == 'field' and s == 'continue' and l == true then
    return '╠═'
  elseif c == 'list' and s == 'stop' and l == true then
    return '└─'
  elseif c == 'field' and s == 'stop' and l == true then
    return '╚═'
  end
end
%    \end{macrocode}

%    \begin{macrocode}
function template.branches(level, connection_type)
  local out = ''

  for i = 1, level - 1  do
    out = out .. template.branch('list', nodetree.state[i]['list'], false)
    out = out .. template.branch('field', nodetree.state[i]['field'], false)
  end
%    \end{macrocode}
% Format the last branches
%    \begin{macrocode}
  if connection_type == 'list' then
    out = out .. template.branch('list', nodetree.state[level]['list'], true)
  else
    out = out .. template.branch('list', nodetree.state[level]['list'], false)
    out = out .. template.branch('field', nodetree.state[level]['field'], true)
  end

  return out
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.init_node_colors()
  template.node_colors = {
    hlist          = template.color('red', 'bright'),
    vlist          = template.color('green', 'bright'),
    rule           = template.color('blue', 'bright'),
    ins            = template.color('blue'),
    mark           = template.color('magenta'),
    adjust         = template.color('cyan'),
    boundary       = template.color('red', 'bright'),
    disc           = template.color('green', 'bright'),
    whatsit        = template.color('yellow', 'bright'),
    local_par      = template.color('blue', 'bright'),
    dir            = template.color('magenta', 'bright'),
    math           = template.color('cyan', 'bright'),
    glue           = template.color('magenta', 'bright'),
    kern           = template.color('green', 'bright'),
    penalty        = template.color('yellow', 'bright'),
    unset          = template.color('blue'),
    style          = template.color('magenta'),
    choice         = template.color('cyan'),
    noad           = template.color('red'),
    radical        = template.color('green'),
    fraction       = template.color('yellow'),
    accent         = template.color('blue'),
    fence          = template.color('magenta'),
    math_char      = template.color('cyan'),
    sub_box        = template.color('red', 'bright'),
    sub_mlist      = template.color('green', 'bright'),
    math_text_char = template.color('yellow', 'bright'),
    delim          = template.color('blue', 'bright'),
    margin_kern    = template.color('magenta', 'bright'),
    glyph          = template.color('cyan', 'bright'),
    align_record   = template.color('red'),
    pseudo_file    = template.color('green'),
    pseudo_line    = template.color('yellow'),
    page_insert    = template.color('blue'),
    split_insert   = template.color('magenta'),
    expr_stack     = template.color('cyan'),
    nested_list    = template.color('red'),
    span           = template.color('green'),
    attribute      = template.color('yellow'),
    glue_spec      = template.color('magenta'),
    attribute_list = template.color('cyan'),
    temp           = template.color('magenta'),
    align_stack    = template.color('red', 'bright'),
    movement_stack = template.color('green', 'bright'),
    if_stack       = template.color('yellow', 'bright'),
    unhyphenated   = template.color('magenta', 'bright'),
    hyphenated     = template.color('cyan', 'bright'),
    delta          = template.color('red'),
    passive        = template.color('green'),
    shape          = template.color('yellow'),
  }
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.type_color(id)
  if not template.node_colors then
    template.init_node_colors()
  end
  return template.node_colors[id]
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.print(text)
  print(text)
end
%    \end{macrocode}
%
% \subsubsection{nodetree}
%
%    \begin{macrocode}
function nodetree.format_field(head, field)
  local out = ''

  if not head[field] or head[field] == 0 then
    return ''
  end

  if options.verbosity < 2 and field == 'prev' or field == 'next' or field == 'id' or field == 'attr' then
    return ''
  end

  if field == 'prev' or field == 'next' then
    out = nodex.node_id(head[field])
  elseif field == 'subtype' then
    out = nodex.subtype(head)
  elseif field == 'width' or field == 'height' or field == 'depth' or field == 'kern' then
    out = template.length(head[field])
  elseif field == 'char' then
    out = template.char(head[field])
  else
    out = tostring(head[field])
  end

  return template.key_value(field, out)
end
%    \end{macrocode}
%
% |level| is a integer beginning with 1. The variable |connection_type|
% is a string, which can be either |list| or |field|. The variable
% |connection_state| is a string, which can be either |continue| or
% |stop|.
%    \begin{macrocode}
function nodetree.set_state(level, connection_type, connection_state)
  if not nodetree.state[level] then
    nodetree.state[level] = {}
  end
  nodetree.state[level][connection_type] = connection_state
end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodetree.analyze_node(head, level)
  local out = {}
  local connection_state

  out = template.type(node.type(head.id), head.id)

  if options.verbosity > 1 then
    out = out .. template.key_value('no', nodex.node_id(head))
  end

  local tmp = {}
  local r = {} -- recurison

  fields = node.fields(head.id, head.subtype)

  for field_id, field_name in pairs(fields) do
    if field_name ~= 'next' and
      field_name ~= 'prev' and
      field_name ~= 'attr' and
      node.is_node(head[field_name]) then
      r[field_name] = head[field_name]
    else
      tmp[#tmp + 1] = nodetree.format_field(head, field_name)
    end
  end

  if head.next then
    connection_state = 'continue'
  else
    connection_state = 'stop'
  end

  nodetree.set_state(level, 'list', connection_state)
  template.print(template.branches(level, 'list') .. out .. table.concat(tmp, ''))

  local max = 0
  for _ in pairs(r) do
    max = max + 1
  end

  local count = 0
  for field_name, recursion_node in pairs(r) do
    count = count + 1
    if count == max then
      connection_state = 'stop'
    else
      connection_state = 'continue'
    end

    nodetree.set_state(level, 'field', connection_state)
    template.print(template.branches(level, 'field') .. template.key_value(field_name))
    nodetree.analyze_list(recursion_node, level + 1)
  end

end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodetree.analyze_list(head, level)
  while head do
    nodetree.analyze_node(head, level)
    head = head.next
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodetree.analyze(head)
  template.print('\n')
  template.print(base.get_callback() .. ':\n│')
  nodetree.analyze_list(head, 1)
  return head
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.set_option(key, value)
  if not options then
    options = {}
  end
  options[key] = value
end
%    \end{macrocode}

%    \begin{macrocode}
function base.get_option(key)
  if not options then
    options = {}
  end
  if options[key] then
    return options[key]
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.set_default_options()
  local defaults = {
    verbosity = 1,
    callback = 'postlinebreak',
    engine = 'luatex',
    color = 'colored',
  }
  if not options then
    options = {}
  end
  for key, value in pairs(defaults) do
    if not options[key] then
      options[key] = value
    end
  end
  options.verbosity = tonumber(options.verbosity)
end
%    \end{macrocode}
%
%    \begin{macrocode}
local callbacks = {}
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.contribute_filter(extrainfo)
  template.callback('contribute_filter', {extrainfo = extrainfo})
  return true
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.buildpage_filter(extrainfo)
  template.callback('buildpage_filter', {extrainfo = extrainfo})
  return true
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.pre_linebreak_filter(head, groupcode)
  template.callback('pre_linebreak_filter', {groupcode = groupcode})
  nodetree.analyze_list(head, 1)
  return true
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.linebreak_filter(head, is_display)
  template.callback('linebreak_filter', {is_display = is_display})
  nodetree.analyze_list(head, 1)
  return true
end
%    \end{macrocode}
%
% TODO: Fix return values, page output
%    \begin{macrocode}
function callbacks.append_to_vlist_filter(head, locationcode, prevdepth, mirrored)
  local variables = {
    locationcode = locationcode,
    prevdepth = prevdepth,
    mirrored = mirrored,
  }
  template.callback('append_to_vlist_filter', variables)
  nodetree.analyze_list(head, 1)
  return true
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.post_linebreak_filter(head, groupcode)
  template.callback('post_linebreak_filter', {groupcode = groupcode})
  nodetree.analyze_list(head, 1)
  return true
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.hpack_filter(head, groupcode, size, packtype, direction, attributelist)
  local variables = {
    groupcode = groupcode,
    size = size,
    packtype = packtype,
    direction = direction,
    attributelist = attributelist,
  }
  template.callback('hpack_filter', variables)
  nodetree.analyze_list(head, 1)
  return true
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.vpack_filter(head, groupcode, size, packtype, maxdepth, direction, attributelist)
  local variables = {
    groupcode = groupcode,
    size = size,
    packtype = packtype,
    maxdepth = maxdepth,
    direction = direction,
    attributelist = attributelist,
  }
  template.callback('vpack_filter', variables)
  nodetree.analyze_list(head, 1)
  return true
end
%    \end{macrocode}
%
% TODO: Fix registration
%    \begin{macrocode}
function callbacks.hpack_qualtity(incident, detail, head, first, last)
  local variables = {
    incident = incident,
    detail = detail,
    first = first,
    last = last,
  }
  template.callback('hpack_qualtity', variables)
  nodetree.analyze_list(head, 1)
  return true
end
%    \end{macrocode}
%
% TODO: Fix registration
%    \begin{macrocode}
function callbacks.vpack_qualtity(incident, detail, head, first, last)
  local variables = {
    incident = incident,
    detail = detail,
    first = first,
    last = last,
  }
  template.callback('vpack_qualtity', variables)
  nodetree.analyze_list(head, 1)
  return true
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.process_rule(head, width, height)
  local variables = {
    width = width,
    height = height,
  }
  template.callback('process_rule', variables)
  nodetree.analyze_list(head, 1)
  return true
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.pre_output_filter(head, groupcode, size, packtype, maxdepth, direction)
  local variables = {
    groupcode = groupcode,
    size = size,
    packtype = packtype,
    maxdepth = maxdepth,
    direction = direction,
  }
  template.callback('pre_output_filter', variables)
  nodetree.analyze_list(head, 1)
  return true
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.hyphenate(head, tail)
  template.callback('hyphenate')
  template.print('head:')
  nodetree.analyze_list(head, 1)
  template.print('tail:')
  nodetree.analyze_list(tail, 1)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.ligaturing(head, tail)
  template.callback('ligaturing')
  template.print('head:')
  nodetree.analyze_list(head, 1)
  template.print('tail:')
  nodetree.analyze_list(tail, 1)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.kerning(head, tail)
  template.callback('kerning')
  template.print('head:')
  nodetree.analyze_list(head, 1)
  template.print('tail:')
  nodetree.analyze_list(tail, 1)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function callbacks.insert_local_par(local_par, location)
  template.callback('insert_local_par', {location = location})
  nodetree.analyze_list(local_par, 1)
  return true
end
%    \end{macrocode}
%
% TODO: Implement newhead as return value
%    \begin{macrocode}
function callbacks.mlist_to_hlist(head, display_type, need_penalties)
  local variables = {
    display_type = display_type,
    need_penalties = need_penalties,
  }
  template.callback('mlist_to_hlist', variables)
  nodetree.analyze_list(head, 1)
end
%    \end{macrocode}
%
% \subsubsection{base}
%
%    \begin{macrocode}
function base.get_callback_name(alias)
  if alias == 'contribute' or alias == 'contributefilter' then
    return 'contribute_filter'

  elseif alias == 'buildpage' or alias == 'buildpagefilter' then
    return 'buildpage_filter'

  elseif alias == 'preline' or alias == 'prelinebreakfilter' then
    return 'pre_linebreak_filter'

  elseif alias == 'line' or alias == 'linebreakfilter' then
    return 'linebreak_filter'

  elseif alias == 'append' or alias == 'appendtovlistfilter' then
    return 'append_to_vlist_filter'

  elseif alias == 'postline' or alias == 'postlinebreakfilter' then
    return 'post_linebreak_filter'

  elseif alias == 'hpack' or alias == 'hpackfilter' then
    return 'hpack_filter'

  elseif alias == 'vpack' or alias == 'vpackfilter' then
    return 'vpack_filter'
  -- TODO: Fix: Unable to register callback
  elseif alias == 'hpackq' or alias == 'hpackquality' then
    return 'hpack_quality'
  -- TODO: Fix: Unable to register callback
  elseif alias == 'vpackq' or alias == 'vpackquality' then
    return 'vpack_quality'

  elseif alias == 'process' or alias == 'processrule' then
    return 'process_rule'

  elseif alias == 'preout' or alias == 'preoutputfilter' then
    return 'pre_output_filter'

  elseif alias == 'hyph' or alias == 'hyphenate' then
    return 'hyphenate'

  elseif alias == 'liga' or alias == 'ligaturing' then
    return 'ligaturing'

  elseif alias == 'kern' or alias == 'kerning' then
   return 'kerning'

  elseif alias == 'insert' or alias == 'insertlocalpar' then
    return 'insert_local_par'

  elseif alias == 'mhlist' or alias == 'mlisttohlist' then
    return 'mlist_to_hlist'

  else
    return 'post_linebreak_filter'
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.register(cb)
  print(cb)
  if options.engine == 'lualatex' then
    luatexbase.add_to_callback(cb, callbacks[cb], 'nodetree')
  else
    id, error = callback.register(cb, callbacks[cb])
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.register_callbacks()
  for alias in string.gmatch(options.callback, '([^,]+)') do
    base.register(base.get_callback_name(alias))
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.unregister(cb)
  if options.engine == 'lualatex' then
    luatexbase.remove_from_callback(cb, 'nodetree')
  else
    id, error = callback.register(cb, nil)
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.unregister_callbacks()
  for alias in string.gmatch(options.callback, '([^,]+)') do
    base.unregister(base.get_callback_name(alias))
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.execute()
  local c = base.get_callback()
  if options.engine == 'lualatex' then
    luatexbase.add_to_callback(c, callbacks.post_linebreak_filter, 'nodetree')
  else
    id, error = callback.register(c, callbacks.post_linebreak_filter)
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.analyze(head)
  nodetree.analyze_list(head, 1)
end
%    \end{macrocode}
%
%    \begin{macrocode}
base.marker = nodex.create_marker
return base
%    \end{macrocode}
% \iffalse
%</luamain>
% \fi
%
% \Finale
\endinput
