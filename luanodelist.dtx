% \iffalse meta-comment
%
% Copyright (C) 2015 by Josef Friedrich <josef@friedrich.rocks>
% ----------------------------------------------------------------------
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, either version 1.3 of this license
% or (at your option) any later version.  The latest version of this
% license is in:
%
%   http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Josef Friedrich.
%
% This work consists of the files luanodelist.dtx and luanodelist.ins
% and the derived filebase luanodelist.sty and luanodelist.lua.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{luanodelist.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{luanodelist}
%<*package>
    [2015/11/13 Package to debug node lists used by LuaTeX]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage{hyperref}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}

\providecommand*{\url}{\texttt}
\GetFileInfo{luanodelist.dtx}
\title{The \textsf{luanodelist} package}
\author{%
  Josef Friedrich\\%
  \url{josef@friedrich.rocks}\\%
  \href{https://github.com/Josef-Friedrich/cloze}{github.com/Josef-Friedrich/luanodelist}%
}
\date{\fileversion~from \filedate}

\maketitle

\section{Option 'channel'}

Value "term"


\begin{verbatim}
\usepackage[channel=term]{luanodelist}
\end{verbatim}

Value "log"

\begin{verbatim}
\usepackage[channel=log]{luanodelist}
\end{verbatim}

Value "term and log"

\begin{verbatim}
\usepackage[channel={term and log}]{luanodelist}
\end{verbatim}

  \DocInput{luanodelist.dtx}
  \pagebreak
  \PrintChanges
  \pagebreak
  \PrintIndex
\end{document}
%</driver>
%<*readme>
# luanodelist

Based on the [gist of Patrick Gundlach](https://gist.github.com/pgundlach/556247).

`luanodelist` displays some debug informations of the node list in the
terminal, when you render a Latex document.

```
lualatex example.tex
```

```
This is LuaTeX, Version beta-0.79.1 (TeX Live 2014) (rev 4971)
 restricted \write18 enabled.
...
(./luanodelist.lua)) (./example.aux)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN nodelist debug
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

GLUE baselineskip: 5.05556pt;

HLIST width 345pt; height 6.94444pt; depth 1.94444pt; glue_set 205; glue_sign 1; glue_order 2;
WHATSIT name: whatsit; type: local_par;

HLIST width 15pt;
GLYPH char: "L"; lang: 0; font: 15; width: 6.25002pt;
GLYPH char: "o"; lang: 0; font: 15; width: 5.00002pt;
GLYPH char: "r"; lang: 0; font: 15; width: 3.91667pt;
GLYPH char: "e"; lang: 0; font: 15; width: 4.44444pt;
GLYPH char: "m"; lang: 0; font: 15; width: 8.33336pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "i"; lang: 0; font: 15; width: 2.77779pt;
GLYPH char: "p"; lang: 0; font: 15; width: 5.55557pt;
DISC prepostreplace;
GLYPH char: "-"; lang: 0; font: 15; width: 3.33333pt;
GLYPH char: "s"; lang: 0; font: 15; width: 3.94444pt;
GLYPH char: "u"; lang: 0; font: 15; width: 5.55557pt;
GLYPH char: "m"; lang: 0; font: 15; width: 8.33336pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "d"; lang: 0; font: 15; width: 5.55557pt;
GLYPH char: "o"; lang: 0; font: 15; width: 5.00002pt;
DISC prepostreplace;
GLYPH char: "-"; lang: 0; font: 15; width: 3.33333pt;
GLYPH char: "l"; lang: 0; font: 15; width: 2.77779pt;
GLYPH char: "o"; lang: 0; font: 15; width: 5.00002pt;
GLYPH char: "r"; lang: 0; font: 15; width: 3.91667pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "s"; lang: 0; font: 15; width: 3.94444pt;
GLYPH char: "i"; lang: 0; font: 15; width: 2.77779pt;
GLYPH char: "t"; lang: 0; font: 15; width: 3.8889pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "a"; lang: 0; font: 15; width: 5.00002pt;
GLYPH char: "m"; lang: 0; font: 15; width: 8.33336pt;
GLYPH char: "e"; lang: 0; font: 15; width: 4.44444pt;
GLYPH char: "t"; lang: 0; font: 15; width: 3.8889pt;
GLYPH char: "."; lang: 0; font: 15; width: 2.77779pt;
PENALTY 10000
GLUE parfillskip: 0pt + 1 fil;
GLUE rightskip: 0pt;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END nodelist debug
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

...
Output written on example.pdf (1 page, 12841 bytes).
Transcript written on example.log.
```



%</readme>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.1}{2015/06/16}{Converted to DTX file}
% \changes{v1.0}{2015/07/08}{Inital release}
%
% \DoNotIndex{\newcommand,\newenvironment,\def,\directlua}
%
% \StopEventually{}
% \pagebreak
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
% \MacroTopsep = 10pt plus 2pt minus 2pt
% \MacrocodeTopsep = 10pt plus 1.2pt minus 1pt
%
% \makeatletter
% \c@CodelineNo 25 \relax
% \makeatother
%
% \subsection{The file \tt{luanodelist.sty}}
%
%
%    \begin{macrocode}
\RequirePackage{luatexbase-mcb}
\RequirePackage{kvoptions}

\SetupKeyvalOptions{
  family=LN,
  prefix=LN@
}
\DeclareStringOption[term and log]{channel}
\DeclareStringOption[postlinebreak]{callback}
\DeclareStringOption[1]{verbosity}
\DeclareStringOption[guided]{interface}

\ProcessKeyvalOptions*

\newcommand{\setluanodelist}[1]{\setkeys{LN}{#1}}

\directlua{
  local options = {}
  options.verbosity = tonumber(\LN@verbosity)
  options.channel = '\LN@channel'
  options.callback = '\LN@callback'
  options.interface = '\LN@interface'

  package.path = './lua/?.lua;' .. package.path

  luanodelist = require("luanodelist")
  luanodelist.get_options(options)
  luanodelist.execute()
}
%    \end{macrocode}
%
% \iffalse
%</package>
%<*luamain>
% \fi
%
% \makeatletter
% \c@CodelineNo 0 \relax
% \makeatother
%
% \subsection{The file \tt{luanodelist.lua}}
%
%    \begin{macrocode}
local colors = require('ansicolors')

local nodex = {}
local template = {}
local process = {}
local guided = {}
local automatic = {}
local base = {}

local options

------------------------------------------------------------------------
-- nodex ; node extended
------------------------------------------------------------------------

-- Get the node id form <node    nil <    172 >    nil : hlist 2>
function nodex.is_node(n)
  return string.find(tostring(n), '^<node%s+%S+%s+<%s+%d+.*>$')
end

-- Get the node id form <node    nil <    172 >    nil : hlist 2>
function nodex.node_id(n)
  return string.gsub(tostring(n), '^<node%s+%S+%s+<%s+(%d+).*', '%1')
end

function nodex.subtype(n)
  local typ = node.type(n.id)

  local subtypes = {
    hlist = {
      [0] = 'unknown origin',
      [1] = 'created by linebreaking',
      [2] = 'explicit box command',
      [3] = 'parindent',
      [4] = 'alignment column or row',
      [5] = 'alignment cell',
    },
    glyph = {
      [0] = 'character',
      [1] = 'glyph',
      [2] = 'ligature',
    },
    disc  = {
      [0] = '\\discretionary',
      [1] = '\\-',
      [2] = '- (auto)',
      [3] = 'h&j (simple)',
      [4] = 'h&j (hard, first item)',
      [5] = 'h&j (hard, second item)',
    },
    glue = {
      [0]   = 'skip',
      [1]   = 'lineskip',
      [2]   = 'baselineskip',
      [3]   = 'parskip',
      [4]   = 'abovedisplayskip',
      [5]   = 'belowdisplayskip',
      [6]   = 'abovedisplayshortskip',
      [7]   = 'belowdisplayshortskip',
      [8]   = 'leftskip',
      [9]   = 'rightskip',
      [10]  = 'topskip',
      [11]  = 'splittopskip',
      [12]  = 'tabskip',
      [13]  = 'spaceskip',
      [14]  = 'xspaceskip',
      [15]  = 'parfillskip',
      [16]  = 'thinmuskip',
      [17]  = 'medmuskip',
      [18]  = 'thickmuskip',
      [100] = 'leaders',
      [101] = 'cleaders',
      [102] = 'xleaders',
      [103] = 'gleaders'
    },
  }

  subtypes.whatsit = node.whatsits()

  local out = ''
  if subtypes[typ] and subtypes[typ][n.subtype] then
    out = subtypes[typ][n.subtype]

    if options.verbosity > 1 then
      out = out .. template.type_id(n.subtype)
    end

    return out
  else
    return tostring(n.subtype)
  end

  assert(false)
end

------------------------------------------------------------------------
-- template
------------------------------------------------------------------------

function template.key_value(key, value)
  return colors.yellow .. key .. ': ' .. colors.white .. value .. '; ' .. colors.reset
end

function template.heading(text)
  return '\n' .. template.line() .. '% ' .. text .. template.line() .. '\n'
end

function template.length(input)
  input = tonumber(input)
  input = input / 2^16
  input = math.floor((input * 10^2) + 0.5) / (10^2)
  return string.format('%gpt', input)
end

function template.char(input)
  return string.format('%q', unicode.utf8.char(input))
end

function template.line()
  return '\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n'
end

function template.frame(text, callback)
  local begin_text = 'BEGIN nodelist debug (Callback: ' .. tostring(callback) .. ')'
  local end_text = 'END nodelist debug'
  return template.heading(begin_text) .. text .. template.heading(end_text)
end

-- t = type
function template.type(t, id)
  local out = ''
  out = template.type_color(t) .. string.upper(t)

  if options.verbosity > 1 then
    out = out .. template.type_id(id)
  end

  return out .. colors.reset  .. ' '
end

function template.type_id(id)
  return '[' .. tostring(id) .. ']'
end

function template.tree(level)
  local out = ''
  for i = 1, level do
    out = '    ' .. out
  end
  return out
end


function template.recursion(field)
  -- return '\n  ' .. colors.red .. string.upper(field) .. ' (recursion): '.. colors.reset  .. ' '
  return '\n  --> ' .. field .. ': '
end

-- t = type
function template.type_color(t)

  if t == 'hlist' then
    return colors.red
  elseif t == 'vlist' then
    return colors.green
  elseif t == 'rule' then
    return colors.yellow
  elseif t == 'disc' then
    return colors.bright .. colors.blue
  elseif t == 'whatsit' then
    return colors.bright .. colors.magenta
  elseif t == 'math' then
    return colors.cyan
  elseif t == 'glue' then
    return colors.bright .. colors.red
  elseif t == 'kern' then
    return colors.bright .. colors.yellow
  elseif t == 'penalty' then
    return colors.blue
  elseif t == 'glyph' then
    return colors.bright .. colors.green
  else
    return colors.magenta
  end
end

function template.print(text)
  print(text)
end

------------------------------------------------------------------------
-- process
------------------------------------------------------------------------

---
-- Process fields which each node has.
---
function process.base(n)
  local out

  out = template.type(node.type(n.id))

  out = out .. template.key_value('subtype', nodex.subtype(n))

  if options.verbosity > 1 then
    out = out .. template.key_value('id', nodex.node_id(n))
  end

  if options.verbosity > 2 then
    out = out .. template.key_value('next', nodex.node_id(n.next))
    out = out .. template.key_value('previous', nodex.node_id(n.prev))
  end

  return out
end

-- Sorted by IDs -------------------------------------------------------

---
-- hlist (0)
---
function process.hlist(n)
  local out = process.base(n)

  if n.width ~= 0 then
    out = out .. template.key_value('width', template.length(n.width))
  end

  if n.height ~= 0 then
    out = out .. template.key_value('height', template.length(n.height))
  end

  if n.depth ~= 0 then
    out = out .. template.key_value('depth', template.length(n.depth))
  end

  if n.glue_set ~= 0 then
    out = out .. template.key_value('glue_set', string.format('%d', n.glue_set))
  end

  if n.glue_sign ~= 0 then
    out = out .. template.key_value('glue_sign', string.format('%d', n.glue_sign))
  end

  if n.glue_order ~= 0 then
    out = out .. template.key_value('glue_order', string.format('%d', n.glue_order))
  end

  if n.shift ~= 0 then
    out = out .. template.key_value('shift', string.format('%d', n.shift))
  end

  out = out

  if n.head then
    out = out .. guided.run_through(n.head, 1)
  end

  return out
end

---
-- vlist (1)
---
function process.vlist(n)
  local out = process.base(n)

  if n.width ~= 0 then
    out = out .. template.key_value('width', template.length(n.width))
  end
  if n.height ~= 0 then
    out = out .. template.key_value('height', template.length(n.height))
  end
  if n.depth ~= 0 then
    out = out .. template.key_value('depth', template.length(n.depth))
  end
  if n.glue_set ~= 0 then
    out = out .. template.key_value('glue_set', n.glue_set)
  end
  if n.glue_sign ~= 0 then
    out = out .. template.key_value('glue_sign', n.glue_sign)
  end
  if n.glue_order ~= 0 then
    out = out .. template.key_value('glue_order', n.glue_order)
  end
  if n.shift ~= 0 then
    out = out .. template.key_value('shift', template.length(n.shift))
  end
  if n.head then
    out = out .. guided.run_through(n.head)
  end

  return out
end

---
-- rule (2)
---
function process.rule(n)
  local out = process.base(n)

  if n.width == -1073741824 then
    out = out .. template.key_value('width', 'flexible')
  else
    out = out .. template.key_value('width', template.length(n.width))
  end

  if n.height == -1073741824 then
    out = out .. template.key_value('height', 'flexible')
  else
    out = out .. template.key_value('height', template.length(n.height))
  end

  if n.depth == -1073741824 then
    out = out .. template.key_value('depth', 'flexible')
  else
    out = out .. template.key_value('depth', template.length(n.depth))
  end

  return out
end

---
-- disc (7)
---
function process.disc(n)
  local out = process.base(n)
  out = out .. template.key_value('subtype', nodex.subtype(n))

  if n.pre then
    out = out .. guided.run_through(n.pre)
  end

  if n.post then
    out = out .. guided.run_through(n.post)
  end

  if n.replace then
    out = out .. guided.run_through(n.replace)
  end

  return out
end

-- Whatsits: sorted by IDs ---------------------------------------------

---
-- whatsit (8) dir (7)
---
function process.whatsit_dir(n)
  return process.base(n) ..
    template.key_value('dir', n.dir)
end

---
-- whatsit (8) pdf_start_link (16)
---
function process.whatsit_pdf_start_link(n)
  return process.base(n) ..
    template.key_value('width', template.length(n.width)) ..
    template.key_value('height', template.length(n.height)) ..
    template.key_value('depth',  template.length(n.depth)) ..
    template.key_value('objnum', n.objnum) ..
    template.key_value('action_type', tostring(n.action_type)) ..
    template.key_value('action_id', tostring(n.action_id)) ..
    template.key_value('named_id', tostring(n.named_id)) ..
    template.key_value('file', tostring(n.file)) ..
    template.key_value('new_window', tostring(n.new_window)) ..
    template.key_value('data', tostring(n.data):gsub('>','\\>'):gsub('<','\\<')) ..
    template.key_value('ref_count', tostring(n.ref_count))
end

---
-- whatsit (8) pdf_colorstack (39)
---
function process.whatsit_pdf_colorstack(n)
  return process.base(n) ..
    template.key_value('stack', string.format('%d', n.stack)) ..
    template.key_value('cmd', string.format('%s', n.cmd)) ..
    template.key_value('data', string.format('%s', n.data))
end

---
-- whatsit (8) user_definded (44)
---
function process.whatsit_user_definded(n)
  local types = {
    [97] = 'attribute node list',
    [100] = 'number',
    [110] = 'node list',
    [115] = 'string',
    [116] = 'token list',
  }
  return process.base(n) ..
    template.key_value('user_id', tostring(n.user_id)) ..
    template.key_value('type', types[tonumber(n.type)]) ..
    template.key_value('value', tostring(n.value))
end

-- End whatsits --------------------------------------------------------

---
-- math (9)
---
function process.math(n)
  return process.base(n) ..
    template.key_value('math', n.subtype == 0 and 'on' or 'off')
end


---
-- glue (10)
---
function process.glue(n)
  local subtype = nodex.subtype(n)
  local spec = string.format('%gpt', n.width / 2^16)

  if n.stretch ~= 0 then
    local stretch_order, shrink_order
    if n.stretch_order == 0 then
      stretch_order = string.format(' + %gpt', n.stretch / 2^16)
    else
      stretch_order = string.format(' + %g fi%s', n.stretch  / 2^16, string.rep('l', n.stretch_order - 1))
    end
    spec = spec .. stretch_order
  end
  if n.shrink ~= 0 then
    if n.shrink_order == 0 then
      shrink_order = string.format(' - %gpt', n.shrink / 2^16)
    else
      shrink_order = string.format(' - %g fi%s', n.shrink  / 2^16, string.rep('l', n.shrink_order - 1))
    end

    spec = spec .. shrink_order
  end
  return process.base(n) .. template.key_value(subtype, spec)
end

---
-- kern (11)
---
function process.kern(n)
  return process.base(n) .. template.key_value('kern', template.length(n.kern))
end

---
-- penalty (12)
---
function process.penalty(n)
  return process.base(n) .. template.key_value('penalty', n.penalty)
end

---
-- glyph (37)
---
function process.glyph(n)
  local out = process.base(n) ..
    template.key_value('char', string.format('%q', unicode.utf8.char(n.char))) ..
    template.key_value('lang', string.format('%d', n.lang)) ..
    template.key_value('font', string.format('%d', n.font)) ..
    template.key_value('width', template.length(n.width))
  if n.components then
    out = out .. guided.run_through(n.components)
  end

  return out
end

------------------------------------------------------------------------
-- guided
------------------------------------------------------------------------

---
--
---
function guided.run_through(head, level)
  local ret = {}
  local typ,nodename
  while head do
    typ = node.type(head.id)

    -- hlist (0)
    if typ == 'hlist' then ret[#ret + 1] = process.hlist(head)
    -- vlist (1)
    elseif typ == 'vlist' then ret[#ret + 1] = process.vlist(head)
    -- rule (2)
    elseif typ == 'rule' then ret[#ret + 1] = process.rule(head)
    -- disc (7)
    elseif typ == 'disc' then ret[#ret + 1] = process.disc(head)

    -- whatsit (8) dir (7)
    elseif typ == 'whatsit' and head.subtype == 7 then ret[#ret + 1] = process.whatsit_dir(head)
    -- whatsit (8) pdf_start_link (16)
    elseif typ == 'whatsit' and head.subtype == 16 then ret[#ret + 1] = process.whatsit_pdf_start_link(head)
    -- whatsit (8) pdf_colorstack (39)
    elseif typ == 'whatsit' and head.subtype == 39 then ret[#ret + 1] = process.whatsit_pdf_colorstack(head)
    -- whatsit (8) user_definded (44)
    elseif typ == 'whatsit' and head.subtype == 44 then ret[#ret + 1] = process.whatsit_user_definded(head)

    -- math (9)
    elseif typ == 'math' then ret[#ret + 1] = process.math(head)
    -- glue (10)
    elseif typ == 'glue' then ret[#ret + 1] = process.glue(head)
    -- kern (11)
    elseif typ == 'kern' then ret[#ret + 1] = process.kern(head)
    -- penalty (12)
    elseif typ == 'penalty' then ret[#ret + 1] = process.penalty(head)
    -- glyph (37)
    elseif typ == 'glyph' then ret[#ret + 1] = process.glyph(head)

    else
      ret[#ret + 1] = automatic.analayze_node(head, level)
    end

    head = head.next
  end
  return table.concat(ret, '\n')
end

---
--
---
function guided.get_nodes(head)
  local out = guided.run_through(head, 1)
  print(template.frame(out,callback))

  return head
end

------------------------------------------------------------------------
-- automatic
------------------------------------------------------------------------

---
--
-- n = node
-- f = field
---
function automatic.format_field(n, f)
  local out = ''

  if not n[f] or n[f] == 0 then
    return ''
  end

  if options.verbosity < 2 and f == 'prev' or f == 'next' or f == 'id' or f == 'attr' then
    return ''
  end

  if f == 'prev' or f == 'next' then
    out = nodex.node_id(n[f])
  elseif f == 'subtype' then
    out = nodex.subtype(n)
  elseif f == 'width' or f == 'height' or f == 'depth' then
    out = template.length(n[f])
  elseif f == 'char' then
    out = template.char(n[f])
  else
    out = tostring(n[f])
  end

  return template.key_value(f, out)
end

---
-- n = node
---
function automatic.analayze_node(n, level)
  local out = {}

  out = template.type(node.type(n.id), n.id)

  if options.verbosity > 1 then
    out = out .. template.key_value('no', nodex.node_id(n))
  end

  local tmp = {}
  local r = {} -- recurison

  fields = node.fields(n.id, n.subtype)

  for field_id,field_name in pairs(fields) do
    if field_name ~= 'next' and
      field_name ~= 'prev' and
      field_name ~= 'attr' and
      nodex.is_node(n[field_name]) then
      r[field_name] = n[field_name]
    else
      tmp[#tmp + 1] = automatic.format_field(n, field_name)
    end
  end

  for field_name,recursion_node in pairs(r) do
    --tmp[#tmp + 1] = template.recursion(field_name) .. automatic.run_through(recursion_node, level + 1)
    tmp[#tmp + 1] = '\n' .. automatic.run_through(recursion_node, level + 1)

  end

  return template.tree(level) .. out .. table.concat(tmp, '')
end

---
--
---
function automatic.run_through(head, level)
  local out = {}
  while head do
    out[#out + 1] = automatic.analayze_node(head, level)
    head = head.next
  end

  return table.concat(out, '\n')
end

---
--
---
function automatic.get_nodes(head)
  local out = automatic.run_through(head, 0)
  template.print(out)

  return head
end

------------------------------------------------------------------------
-- base
------------------------------------------------------------------------

function base.get_callback(key)
  if key == 'prelinebreak' then callback = 'pre_linebreak_filter'
  elseif key == 'linebreak' then callback = 'linebreak_filter'
  elseif key == 'postlinebreak' then callback = 'post_linebreak_filter'
  elseif key == 'hpack' then callback = 'hpack_filter'
  elseif key == 'vpack' then callback = 'vpack_filter'
  elseif key == 'hyphenate' then callback = 'hyphenate'
  elseif key == 'ligaturing' then callback = 'ligaturing'
  elseif key == 'kerning' then callback = 'kerning'
  elseif key == 'mhlist' then callback = 'mlist_to_hlist'
  else callback = 'post_linebreak_filter'
  end

  return callback
end

function base.get_options(localoptions)
  options = localoptions
end

function base.execute()
  if options.interface == 'guided' then
    luatexbase.add_to_callback(base.get_callback(options.callback), guided.get_nodes, 'guided', 1000)
  else
    luatexbase.add_to_callback(base.get_callback(options.callback), automatic.get_nodes, 'automatic', 1000)
  end
end

function base.analyze(n)
  local out = template.line() ..
    automatic.run_through(n, 1) ..
    template.line()

  template.print(out)
end

return base
%    \end{macrocode}
% \iffalse
%</luamain>
%<*luaansicolors>
% \fi
%    \begin{macrocode}
-- Copyright (c) 2009 Rob Hoelz <rob@hoelzro.net>
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-- THE SOFTWARE.

local pairs = pairs
local tostring = tostring
local setmetatable = setmetatable
local schar = string.char

module 'ansicolors'

local colormt = {}

function colormt:__tostring()
    return self.value
end

function colormt:__concat(other)
    return tostring(self) .. tostring(other)
end

function colormt:__call(s)
    return self .. s .. _M.reset
end

colormt.__metatable = {}

local function makecolor(value)
    return setmetatable({ value = schar(27) .. '[' .. tostring(value) .. 'm' }, colormt)
end

local colors = {
    -- attributes
    reset = 0,
    clear = 0,
    bright = 1,
    dim = 2,
    underscore = 4,
    blink = 5,
    reverse = 7,
    hidden = 8,

    -- foreground
    black = 30,
    red = 31,
    green = 32,
    yellow = 33,
    blue = 34,
    magenta = 35,
    cyan = 36,
    white = 37,

    -- background
    onblack = 40,
    onred = 41,
    ongreen = 42,
    onyellow = 43,
    onblue = 44,
    onmagenta = 45,
    oncyan = 46,
    onwhite = 47,
}

for c, v in pairs(colors) do
    _M[c] = makecolor(v)
end
%    \end{macrocode}
% \iffalse
%</luaansicolors>
% \fi
%
% \Finale
\endinput
