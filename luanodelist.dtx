% \iffalse meta-comment
%
% Copyright (C) 2015 by Josef Friedrich <josef@friedrich.rocks>
% ----------------------------------------------------------------------
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, either version 1.3 of this license
% or (at your option) any later version.  The latest version of this
% license is in:
%
%   http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Josef Friedrich.
%
% This work consists of the files luanodelist.dtx and luanodelist.ins
% and the derived filebase luanodelist.sty and luanodelist.lua.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{luanodelist.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{luanodelist}
%<*package>
    [2015/11/13 Package to debug node lists used by LuaTeX]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage{hyperref}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}

\providecommand*{\url}{\texttt}
\GetFileInfo{luanodelist.dtx}
\title{The \textsf{luanodelist} package}
\author{%
  Josef Friedrich\\%
  \url{josef@friedrich.rocks}\\%
  \href{https://github.com/Josef-Friedrich/cloze}{github.com/Josef-Friedrich/luanodelist}%
}
\date{\fileversion~from \filedate}

\maketitle

\tableofcontents

\section{Option 'channel'}

Value "term"


\begin{verbatim}
\usepackage[channel=term]{luanodelist}
\end{verbatim}

Value "log"

\begin{verbatim}
\usepackage[channel=log]{luanodelist}
\end{verbatim}

Value "term and log"

\begin{verbatim}
\usepackage[channel={term and log}]{luanodelist}
\end{verbatim}

  \DocInput{luanodelist.dtx}
  \pagebreak
  \PrintChanges
  \pagebreak
  \PrintIndex
\end{document}
%</driver>
%<*readme>
# luanodelist

Based on the [gist of Patrick Gundlach](https://gist.github.com/pgundlach/556247).

`luanodelist` displays some debug informations of the node list in the
terminal, when you render a Latex document.

```
lualatex example.tex
```

```
This is LuaTeX, Version beta-0.79.1 (TeX Live 2014) (rev 4971)
 restricted \write18 enabled.
...
(./luanodelist.lua)) (./example.aux)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN nodelist debug
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

GLUE baselineskip: 5.05556pt;

HLIST width 345pt; height 6.94444pt; depth 1.94444pt; glue_set 205; glue_sign 1; glue_order 2;
WHATSIT name: whatsit; type: local_par;

HLIST width 15pt;
GLYPH char: "L"; lang: 0; font: 15; width: 6.25002pt;
GLYPH char: "o"; lang: 0; font: 15; width: 5.00002pt;
GLYPH char: "r"; lang: 0; font: 15; width: 3.91667pt;
GLYPH char: "e"; lang: 0; font: 15; width: 4.44444pt;
GLYPH char: "m"; lang: 0; font: 15; width: 8.33336pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "i"; lang: 0; font: 15; width: 2.77779pt;
GLYPH char: "p"; lang: 0; font: 15; width: 5.55557pt;
DISC prepostreplace;
GLYPH char: "-"; lang: 0; font: 15; width: 3.33333pt;
GLYPH char: "s"; lang: 0; font: 15; width: 3.94444pt;
GLYPH char: "u"; lang: 0; font: 15; width: 5.55557pt;
GLYPH char: "m"; lang: 0; font: 15; width: 8.33336pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "d"; lang: 0; font: 15; width: 5.55557pt;
GLYPH char: "o"; lang: 0; font: 15; width: 5.00002pt;
DISC prepostreplace;
GLYPH char: "-"; lang: 0; font: 15; width: 3.33333pt;
GLYPH char: "l"; lang: 0; font: 15; width: 2.77779pt;
GLYPH char: "o"; lang: 0; font: 15; width: 5.00002pt;
GLYPH char: "r"; lang: 0; font: 15; width: 3.91667pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "s"; lang: 0; font: 15; width: 3.94444pt;
GLYPH char: "i"; lang: 0; font: 15; width: 2.77779pt;
GLYPH char: "t"; lang: 0; font: 15; width: 3.8889pt;
GLUE skip: 3.33333pt + 1.66666pt - 1.11111pt;
GLYPH char: "a"; lang: 0; font: 15; width: 5.00002pt;
GLYPH char: "m"; lang: 0; font: 15; width: 8.33336pt;
GLYPH char: "e"; lang: 0; font: 15; width: 4.44444pt;
GLYPH char: "t"; lang: 0; font: 15; width: 3.8889pt;
GLYPH char: "."; lang: 0; font: 15; width: 2.77779pt;
PENALTY 10000
GLUE parfillskip: 0pt + 1 fil;
GLUE rightskip: 0pt;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END nodelist debug
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

...
Output written on example.pdf (1 page, 12841 bytes).
Transcript written on example.log.
```

# UTF8 Box drawing symbols

## Light

```
│ │
│ ├─┤field1: 1pt├┤field2: 1pt│
│ └─
└─
```

## Heavy

```
┃ ┃
┃ ┣━┫field1: 1pt┣┫field2: 1pt┃
┃ ┗━
┗━
```

## Double

```
║ ║
║ ╠═╣field1: 1pt╠╣field2: 1pt║
║ ╚═
╚═
```

%</readme>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.1}{2015/06/16}{Converted to DTX file}
% \changes{v1.0}{2015/07/08}{Inital release}
%
% \DoNotIndex{\newcommand,\newenvironment,\def,\directlua}
%
% \StopEventually{}
% \pagebreak
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
% \MacroTopsep = 10pt plus 2pt minus 2pt
% \MacrocodeTopsep = 10pt plus 1.2pt minus 1pt
%
% \makeatletter
% \c@CodelineNo 25 \relax
% \makeatother
%
% \subsection{The file \tt{luanodelist.sty}}
%
%
%    \begin{macrocode}
\RequirePackage{luatexbase-mcb}
\RequirePackage{kvoptions}

\SetupKeyvalOptions{
  family=LN,
  prefix=LN@
}
\DeclareStringOption[term and log]{channel}
\DeclareStringOption[postlinebreak]{callback}
\DeclareStringOption[1]{verbosity}

\ProcessKeyvalOptions*

\newcommand{\setluanodelist}[1]{\setkeys{LN}{#1}}

\directlua{
  local options = {}
  options.verbosity = tonumber(\LN@verbosity)
  options.channel = '\LN@channel'
  options.callback = '\LN@callback'

  package.path = './lua/?.lua;' .. package.path

  luanodelist = require("luanodelist")
  luanodelist.get_options(options)
  luanodelist.execute()
}
%    \end{macrocode}
%
% \iffalse
%</package>
%<*luamain>
% \fi
%
% \makeatletter
% \c@CodelineNo 0 \relax
% \makeatother
%
% \subsection{The file \tt{luanodelist.lua}}
%
%    \begin{macrocode}
local colors = require('ansicolors')
%    \end{macrocode}
%
%    \begin{macrocode}
local nodex = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local template = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local tree = {}
%    \end{macrocode}
%
% Nodes in Lua\TeX are connected. The tree view distinguishs betweens
% the |list| and |field| connections.

% \begin{itemize}
%  \item |list|: Nodes, which are double connected by |next| and
%        |previous| fields.
%  \item |field|: Connections to nodes by other fields than |next| and
%        |previous| fields, e. g. |head|, |pre|.
% \end{itemize}
%
% The lua table named |tree| holds states values for the present tree
% item.
% \begin{verbatim}
%  tree:
%    - 1:
%      - list: continue
%      - field: stop
%    - 2:
%      - list: continue
%      - field: stop
% \end{verbatim}
%    \begin{macrocode}
tree.state = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local base = {}
%    \end{macrocode}
%
% Nodes in Lua\TeX are connected. The tree view distinguishs betweens
% the |list| and |field| connections.

% \begin{itemize}
%  \item |list|: Nodes, which are double connected by |next| and
%        |previous| fields.
%  \item |field|: Connections to nodes by other fields than |next| and
%        |previous| fields, e. g. |head|, |pre|.
% \end{itemize}
%
% The lua table named |tree| holds states values for the present tree
% item.
% \begin{verbatim}
%  tree:
%    - 1:
%      - list: continue
%      - field: stop
%    - 2:
%      - list: continue
%      - field: stop
% \end{verbatim}
%    \begin{macrocode}
tree.state = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local options
%    \end{macrocode}
%
% \subsubsection{nodex --- node extended}
%
%    \begin{macrocode}
function nodex.is_node(n)
  return string.find(tostring(n), '^<node%s+%S+%s+<%s+%d+.*>$')
end
%    \end{macrocode}
% Get the node id form, e. g.:
% \begin{verbatim}
% <node    nil <    172 >    nil : hlist 2>
% \end{verbatim}
%    \begin{macrocode}
function nodex.node_id(n)
  return string.gsub(tostring(n), '^<node%s+%S+%s+<%s+(%d+).*', '%1')
end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodex.subtype(n)
  local typ = node.type(n.id)

  local subtypes = {
    hlist = {
      [0] = 'unknown origin',
      [1] = 'created by linebreaking',
      [2] = 'explicit box command',
      [3] = 'parindent',
      [4] = 'alignment column or row',
      [5] = 'alignment cell',
    },
    glyph = {
      [0] = 'character',
      [1] = 'glyph',
      [2] = 'ligature',
    },
    disc  = {
      [0] = '\\discretionary',
      [1] = '\\-',
      [2] = '- (auto)',
      [3] = 'h&j (simple)',
      [4] = 'h&j (hard, first item)',
      [5] = 'h&j (hard, second item)',
    },
    glue = {
      [0]   = 'skip',
      [1]   = 'lineskip',
      [2]   = 'baselineskip',
      [3]   = 'parskip',
      [4]   = 'abovedisplayskip',
      [5]   = 'belowdisplayskip',
      [6]   = 'abovedisplayshortskip',
      [7]   = 'belowdisplayshortskip',
      [8]   = 'leftskip',
      [9]   = 'rightskip',
      [10]  = 'topskip',
      [11]  = 'splittopskip',
      [12]  = 'tabskip',
      [13]  = 'spaceskip',
      [14]  = 'xspaceskip',
      [15]  = 'parfillskip',
      [16]  = 'thinmuskip',
      [17]  = 'medmuskip',
      [18]  = 'thickmuskip',
      [100] = 'leaders',
      [101] = 'cleaders',
      [102] = 'xleaders',
      [103] = 'gleaders'
    },
  }

  subtypes.whatsit = node.whatsits()

  local out = ''
  if subtypes[typ] and subtypes[typ][n.subtype] then
    out = subtypes[typ][n.subtype]

    if options.verbosity > 1 then
      out = out .. template.type_id(n.subtype)
    end

    return out
  else
    return tostring(n.subtype)
  end

  assert(false)
end
%    \end{macrocode}
%
% \subsubsection{template}
%
%    \begin{macrocode}
function template.key_value(key, value)
  return colors.yellow .. key .. ': ' .. colors.white .. value .. '; ' .. colors.reset
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.heading(text)
  return '\n' .. template.line() .. '% ' .. text .. template.line() .. '\n'
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.length(input)
  input = tonumber(input)
  input = input / 2^16
  input = math.floor((input * 10^2) + 0.5) / (10^2)
  return string.format('%gpt', input)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.char(input)
  return string.format('%q', unicode.utf8.char(input))
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.line()
  return '\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n'
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.frame(text, callback)
  local begin_text = 'BEGIN nodelist debug (Callback: ' .. tostring(callback) .. ')'
  local end_text = 'END nodelist debug'
  return template.heading(begin_text) .. text .. template.heading(end_text)
end
%    \end{macrocode}
% t = type
%    \begin{macrocode}
function template.type(t, id)
  local out = ''
  out = template.type_color(t) .. string.upper(t)

  if options.verbosity > 1 then
    out = out .. template.type_id(id)
  end

  return out .. colors.reset  .. ' '
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.type_id(id)
  return '[' .. tostring(id) .. ']'
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.tree(head, level, recursion_field)
  local out = ''
  for i = 1, level - 1  do
    if tree[i] then
      out = out .. '│  '
    else
      out = out .. '   '
    end
  end
  if head.next then
    out = out .. '├──'
    tree[level] = true
  else
    out = out .. '└──'
    tree[level] = false
  end
  if recursion_field and recursion_field ~= tree.last_recursion_field then
    out = out .. recursion_field .. ': '
  end
  tree.last_recursion_field = recursion_field
  return out
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.type_color(id)
  if id == 'hlist' then
    return colors.red
  elseif id == 'vlist' then
    return colors.green
  elseif id == 'rule' then
    return colors.yellow
  elseif id == 'disc' then
    return colors.bright .. colors.blue
  elseif id == 'whatsit' then
    return colors.bright .. colors.magenta
  elseif id == 'math' then
    return colors.cyan
  elseif id == 'glue' then
    return colors.bright .. colors.red
  elseif id == 'kern' then
    return colors.bright .. colors.yellow
  elseif id == 'penalty' then
    return colors.blue
  elseif id == 'glyph' then
    return colors.bright .. colors.green
  else
    return colors.magenta
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function template.print(text)
  print(text)
end
%    \end{macrocode}
%
% \subsubsection{tree}
%
%    \begin{macrocode}
function tree.format_field(head, field)
  local out = ''

  if not head[field] or head[field] == 0 then
    return ''
  end

  if options.verbosity < 2 and field == 'prev' or field == 'next' or field == 'id' or field == 'attr' then
    return ''
  end

  if field == 'prev' or field == 'next' then
    out = nodex.node_id(head[field])
  elseif field == 'subtype' then
    out = nodex.subtype(head)
  elseif field == 'width' or field == 'height' or field == 'depth' then
    out = template.length(head[field])
  elseif field == 'char' then
    out = template.char(head[field])
  else
    out = tostring(head[field])
  end

  return template.key_value(field, out)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function tree.analayze_node(head, level, recursion_field)
  local out = {}

  out = template.type(node.type(head.id), head.id)

  if options.verbosity > 1 then
    out = out .. template.key_value('no', nodex.node_id(head))
  end

  local tmp = {}
  local r = {} -- recurison

  fields = node.fields(head.id, head.subtype)

  for field_id,field_name in pairs(fields) do
    if field_name ~= 'next' and
      field_name ~= 'prev' and
      field_name ~= 'attr' and
      nodex.is_node(head[field_name]) then
      r[field_name] = head[field_name]
    else
      tmp[#tmp + 1] = tree.format_field(head, field_name)
    end
  end

  for field_name,recursion_node in pairs(r) do
    tree.run_through(recursion_node, level + 1, field_name)
  end

  template.print(template.tree(head, level, recursion_field) .. out .. table.concat(tmp, ''))
end
%    \end{macrocode}
%
%    \begin{macrocode}
function tree.run_through(head, level, recursion_field)
  while head do
    tree.analayze_node(head, level, recursion_field)
    head = head.next
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function tree.get_nodes(head)
  local out = tree.run_through(head, 1)
  print('\n')
  template.print(out)

  return head
end
%    \end{macrocode}
%
% \subsubsection{base}
%
%    \begin{macrocode}
function base.get_callback(key)
  if key == 'prelinebreak' then callback = 'pre_linebreak_filter'
  elseif key == 'linebreak' then callback = 'linebreak_filter'
  elseif key == 'postlinebreak' then callback = 'post_linebreak_filter'
  elseif key == 'hpack' then callback = 'hpack_filter'
  elseif key == 'vpack' then callback = 'vpack_filter'
  elseif key == 'hyphenate' then callback = 'hyphenate'
  elseif key == 'ligaturing' then callback = 'ligaturing'
  elseif key == 'kerning' then callback = 'kerning'
  elseif key == 'mhlist' then callback = 'mlist_to_hlist'
  else callback = 'post_linebreak_filter'
  end

  return callback
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.get_options(localoptions)
  options = localoptions
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.execute()
  luatexbase.add_to_callback(base.get_callback(options.callback), tree.get_nodes, 'tree')
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.analyze(n)
  local out = template.line() ..
    tree.run_through(n, 1) ..
    template.line()

  template.print(out)
end
%    \end{macrocode}
%
%    \begin{macrocode}
return base
%    \end{macrocode}
% \iffalse
%</luamain>
%<*luaansicolors>
% \fi
%
% \makeatletter
% \c@CodelineNo 0 \relax
% \makeatother
%
% \subsection{The file \tt{ansicolors.lua}}
%
%    \begin{macrocode}
-- Copyright (c) 2009 Rob Hoelz <rob@hoelzro.net>
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-- THE SOFTWARE.

local pairs = pairs
local tostring = tostring
local setmetatable = setmetatable
local schar = string.char

module 'ansicolors'

local colormt = {}

function colormt:__tostring()
    return self.value
end

function colormt:__concat(other)
    return tostring(self) .. tostring(other)
end

function colormt:__call(s)
    return self .. s .. _M.reset
end

colormt.__metatable = {}

local function makecolor(value)
    return setmetatable({ value = schar(27) .. '[' .. tostring(value) .. 'm' }, colormt)
end

local colors = {
    -- attributes
    reset = 0,
    clear = 0,
    bright = 1,
    dim = 2,
    underscore = 4,
    blink = 5,
    reverse = 7,
    hidden = 8,

    -- foreground
    black = 30,
    red = 31,
    green = 32,
    yellow = 33,
    blue = 34,
    magenta = 35,
    cyan = 36,
    white = 37,

    -- background
    onblack = 40,
    onred = 41,
    ongreen = 42,
    onyellow = 43,
    onblue = 44,
    onmagenta = 45,
    oncyan = 46,
    onwhite = 47,
}

for c, v in pairs(colors) do
    _M[c] = makecolor(v)
end
%    \end{macrocode}
% \iffalse
%</luaansicolors>
% \fi
%
% \Finale
\endinput
